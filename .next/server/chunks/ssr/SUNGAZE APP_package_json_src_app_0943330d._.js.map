{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/cobyobi/SUNGAZE%20APP/package.json/src/app/hooks/useVoice.ts"],"sourcesContent":["\"use client\";\n\nimport { useState, useRef, useCallback, useEffect } from 'react';\nimport { initializeElevenLabs, initializeCompletionVoice, SACRED_PREPARATION_TEXT, SESSION_COMPLETION_TEXT, PALMING_INSTRUCTIONS_TEXT, PALM_WARMING_TEXT, EYE_SANCTUARY_TEXT, INNER_SUN_MEDITATION_TEXT } from '../lib/elevenlabs';\nimport { initializeWebSpeech, WebSpeechService } from '../lib/speechSynthesis';\nimport { MeditativeChimes } from '../lib/meditativeChimes';\n\nexport interface VoiceState {\n  isPlaying: boolean;\n  isLoading: boolean;\n  isReady: boolean;\n  error: string | null;\n  duration: number;\n  currentTime: number;\n}\n\nexport function useVoice() {\n  const [voiceState, setVoiceState] = useState<VoiceState>({\n    isPlaying: false,\n    isLoading: false,\n    isReady: false,\n    error: null,\n    duration: 0,\n    currentTime: 0,\n  });\n\n  const autoPlayRef = useRef(false);\n\n  const audioRef = useRef<HTMLAudioElement | null>(null);\n  const completionAudioRef = useRef<HTMLAudioElement | null>(null);\n  const palmingAudioRef = useRef<HTMLAudioElement | null>(null);\n  const activeAudioRefs = useRef<Set<HTMLAudioElement>>(new Set()); // Track all active audio elements\n  const elevenLabsService = useRef(initializeElevenLabs());\n  const completionVoiceService = useRef(initializeCompletionVoice());\n  const webSpeechService = useRef<WebSpeechService | null>(null);\n  const chimeService = useRef<MeditativeChimes>(new MeditativeChimes());\n  const isUsingWebSpeech = useRef(false);\n  const isUsingChimes = useRef(false);\n\n  // Initialize and preload sacred preparation audio\n  // Preload completion message\n  const preloadCompletionMessage = useCallback(async () => {\n    if (!completionVoiceService.current) return;\n    \n    try {\n      const audioUrl = await completionVoiceService.current.generateSpeechUrl(SESSION_COMPLETION_TEXT);\n      const audio = new Audio(audioUrl);\n      completionAudioRef.current = audio;\n      audio.load(); // Preload the audio\n    } catch (error) {\n      console.error('Failed to preload completion message:', error);\n    }\n  }, []);\n\n  // Preload palming instructions\n  const preloadPalmingInstructions = useCallback(async () => {\n    if (!completionVoiceService.current) return;\n    \n    try {\n      const audioUrl = await completionVoiceService.current.generateSpeechUrl(PALMING_INSTRUCTIONS_TEXT);\n      const audio = new Audio(audioUrl);\n      palmingAudioRef.current = audio;\n      audio.load(); // Preload the audio\n    } catch (error) {\n      console.error('Failed to preload palming instructions:', error);\n    }\n  }, []);\n\n  const initializeVoice = useCallback(async (autoPlay = false) => {\n    autoPlayRef.current = autoPlay;\n    setVoiceState(prev => ({ ...prev, isLoading: true, error: null }));\n\n    // Skip problematic voice systems and go straight to chimes for better reliability\n    console.log('Initializing sacred chimes for reliable voice experience...');\n    initializeChimeFallback(autoPlay);\n  }, []);\n\n  const initializeWebSpeechFallback = useCallback((autoPlay = false) => {\n    if (!webSpeechService.current) {\n      webSpeechService.current = initializeWebSpeech();\n    }\n\n    if (!webSpeechService.current) {\n      setVoiceState(prev => ({ \n        ...prev, \n        error: 'Voice synthesis not available in this browser',\n        isLoading: false,\n        isReady: false \n      }));\n      return;\n    }\n\n    isUsingWebSpeech.current = true;\n    setVoiceState(prev => ({ \n      ...prev, \n      isLoading: false, \n      isReady: true,\n      duration: 0, // Web Speech API doesn't provide duration info\n      currentTime: 0 \n    }));\n\n    // Auto-play if requested\n    if (autoPlay) {\n      setTimeout(() => {\n        playWebSpeech(SACRED_PREPARATION_TEXT);\n      }, 100);\n    }\n  }, []);\n\n  const initializeChimeFallback = useCallback((autoPlay = false) => {\n    console.log('Initializing sacred chimes as voice fallback...');\n    \n    isUsingChimes.current = true;\n    isUsingWebSpeech.current = false;\n    \n    setVoiceState(prev => ({ \n      ...prev, \n      isLoading: false, \n      isReady: true,\n      duration: 0, // Chimes don't have specific durations\n      currentTime: 0,\n      error: null\n    }));\n\n    // Auto-play preparation chime if requested\n    if (autoPlay) {\n      setTimeout(async () => {\n        await chimeService.current.playPreparationChime();\n        setVoiceState(prev => ({ ...prev, isPlaying: true }));\n        \n        // Set playing to false after chime completes (approximately 3 seconds)\n        setTimeout(() => {\n          setVoiceState(prev => ({ ...prev, isPlaying: false }));\n        }, 3000);\n      }, 100);\n    }\n  }, []);\n\n  const playWebSpeech = useCallback(async (text: string) => {\n    if (!webSpeechService.current) return;\n\n    try {\n      setVoiceState(prev => ({ ...prev, isPlaying: true }));\n      await webSpeechService.current.speak(text);\n      setVoiceState(prev => ({ ...prev, isPlaying: false }));\n    } catch (error) {\n      console.error('Web Speech error:', error);\n      setVoiceState(prev => ({ \n        ...prev, \n        error: null, // Don't show error, just fall back to chimes\n        isPlaying: false \n      }));\n    }\n  }, []);\n\n  const playVoice = useCallback(async () => {\n    if (isUsingChimes.current) {\n      setVoiceState(prev => ({ ...prev, isPlaying: true }));\n      await chimeService.current.playPreparationChime();\n      setTimeout(() => {\n        setVoiceState(prev => ({ ...prev, isPlaying: false }));\n      }, 3000);\n    } else if (isUsingWebSpeech.current && webSpeechService.current) {\n      playWebSpeech(SACRED_PREPARATION_TEXT);\n    } else if (audioRef.current && voiceState.isReady) {\n      audioRef.current.play().catch(error => {\n        console.error('Voice playback error:', error);\n        setVoiceState(prev => ({ \n          ...prev, \n          error: 'Failed to play audio' \n        }));\n      });\n    }\n  }, [voiceState.isReady, playWebSpeech]);\n\n  const pauseVoice = useCallback(() => {\n    if (isUsingChimes.current) {\n      // Chimes can't really be paused, just stop the state\n      setVoiceState(prev => ({ ...prev, isPlaying: false }));\n    } else if (isUsingWebSpeech.current && webSpeechService.current) {\n      webSpeechService.current.pause();\n      setVoiceState(prev => ({ ...prev, isPlaying: false }));\n    } else if (audioRef.current) {\n      audioRef.current.pause();\n    }\n  }, []);\n\n  const stopVoice = useCallback(() => {\n    console.log('Stopping all voice audio...');\n    \n    // Stop all active audio elements\n    activeAudioRefs.current.forEach(audio => {\n      if (audio) {\n        audio.pause();\n        audio.currentTime = 0;\n      }\n    });\n    activeAudioRefs.current.clear();\n    \n    if (isUsingChimes.current) {\n      // Chimes naturally stop, just reset state\n      setVoiceState(prev => ({ ...prev, isPlaying: false, currentTime: 0 }));\n    } else if (isUsingWebSpeech.current && webSpeechService.current) {\n      webSpeechService.current.stop();\n      setVoiceState(prev => ({ ...prev, isPlaying: false, currentTime: 0 }));\n    } else if (audioRef.current) {\n      audioRef.current.pause();\n      audioRef.current.currentTime = 0;\n    }\n    \n    // Also stop the main audio refs\n    if (completionAudioRef.current) {\n      completionAudioRef.current.pause();\n      completionAudioRef.current.currentTime = 0;\n    }\n    if (palmingAudioRef.current) {\n      palmingAudioRef.current.pause();\n      palmingAudioRef.current.currentTime = 0;\n    }\n  }, []);\n\n  // Generate and play gong sound\n  const playGong = useCallback(() => {\n    try {\n      const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();\n      \n      // Create oscillator for the gong sound\n      const oscillator = audioContext.createOscillator();\n      const gainNode = audioContext.createGain();\n      \n      // Connect nodes\n      oscillator.connect(gainNode);\n      gainNode.connect(audioContext.destination);\n      \n      // Configure gong-like sound\n      oscillator.frequency.setValueAtTime(200, audioContext.currentTime); // Start frequency\n      oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 2); // Decay to lower frequency\n      \n      // Configure envelope (fade out)\n      gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);\n      gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 3);\n      \n      oscillator.type = 'sine';\n      oscillator.start(audioContext.currentTime);\n      oscillator.stop(audioContext.currentTime + 3);\n      \n    } catch (error) {\n      console.error('Gong sound error:', error);\n    }\n  }, []);\n\n  // Play session completion message\n  const playCompletionMessage = useCallback(async () => {\n    // Use chimes if that's our current fallback\n    if (isUsingChimes.current) {\n      setVoiceState(prev => ({ ...prev, isPlaying: true }));\n      await chimeService.current.playCompletionChime();\n      setTimeout(() => {\n        setVoiceState(prev => ({ ...prev, isPlaying: false }));\n      }, 4000); // Completion chimes are longer\n      return;\n    }\n\n    // Try Web Speech API fallback if ElevenLabs is not working\n    if (isUsingWebSpeech.current || !completionVoiceService.current) {\n      if (webSpeechService.current) {\n        await playWebSpeech(SESSION_COMPLETION_TEXT);\n      }\n      return;\n    }\n\n    try {\n      let audio = completionAudioRef.current;\n      \n      // If not preloaded, generate it now\n      if (!audio && completionVoiceService.current) {\n        setVoiceState(prev => ({ ...prev, isLoading: true, error: null }));\n        const audioUrl = await completionVoiceService.current.generateSpeechUrl(SESSION_COMPLETION_TEXT);\n        audio = new Audio(audioUrl);\n        completionAudioRef.current = audio;\n      }\n      \n      if (!audio) {\n        console.warn('ElevenLabs completion voice service not available, using fallback');\n        // Use chimes as preferred fallback over computer voice\n        if (chimeService.current) {\n          setVoiceState(prev => ({ ...prev, isPlaying: true }));\n          await chimeService.current.playCompletionChime();\n          setTimeout(() => {\n            setVoiceState(prev => ({ ...prev, isPlaying: false }));\n          }, 4000);\n        } else if (webSpeechService.current) {\n          await playWebSpeech(SESSION_COMPLETION_TEXT);\n        }\n        return;\n      }\n\n      // Set up event listeners for completion audio\n      audio.onloadedmetadata = () => {\n        setVoiceState(prev => ({ \n          ...prev, \n          isLoading: false, \n          duration: audio.duration \n        }));\n      };\n\n      audio.ontimeupdate = () => {\n        setVoiceState(prev => ({ \n          ...prev, \n          currentTime: audio.currentTime \n        }));\n      };\n\n      audio.onplay = () => {\n        setVoiceState(prev => ({ ...prev, isPlaying: true }));\n      };\n\n      audio.onpause = () => {\n        setVoiceState(prev => ({ ...prev, isPlaying: false }));\n      };\n\n      audio.onended = () => {\n        setVoiceState(prev => ({ \n          ...prev, \n          isPlaying: false, \n          currentTime: 0 \n        }));\n      };\n\n      audio.onerror = () => {\n        setVoiceState(prev => ({ \n          ...prev, \n          error: 'Failed to play completion message',\n          isLoading: false,\n          isPlaying: false \n        }));\n      };\n\n      // Pause current audio if any and play completion message\n      if (audioRef.current) {\n        audioRef.current.pause();\n      }\n      \n      // Reset and play\n      audio.currentTime = 0;\n      await audio.play();\n\n    } catch (error) {\n      console.error('Completion voice error:', error);\n      setVoiceState(prev => ({ \n        ...prev, \n        error: error instanceof Error ? error.message : 'Failed to play completion message',\n        isLoading: false,\n        isPlaying: false \n      }));\n    }\n  }, []);\n\n  // Play palming instructions message\n  const playPalmingInstructions = useCallback(async () => {\n    // Use chimes if that's our current fallback\n    if (isUsingChimes.current) {\n      setVoiceState(prev => ({ ...prev, isPlaying: true }));\n      await chimeService.current.playPalmingChime();\n      setTimeout(() => {\n        setVoiceState(prev => ({ ...prev, isPlaying: false }));\n      }, 4500); // Palming chimes are deep and longer\n      return;\n    }\n\n    try {\n      let audio = palmingAudioRef.current;\n      \n      // If not preloaded, generate it now\n      if (!audio && completionVoiceService.current) {\n        setVoiceState(prev => ({ ...prev, isLoading: true, error: null }));\n        const audioUrl = await completionVoiceService.current.generateSpeechUrl(PALMING_INSTRUCTIONS_TEXT);\n        audio = new Audio(audioUrl);\n        palmingAudioRef.current = audio;\n      }\n      \n      if (!audio) {\n        console.warn('ElevenLabs palming voice service not available, using chime fallback');\n        // Use chimes as preferred fallback\n        if (chimeService.current) {\n          setVoiceState(prev => ({ ...prev, isPlaying: true }));\n          await chimeService.current.playPalmingChime();\n          setTimeout(() => {\n            setVoiceState(prev => ({ ...prev, isPlaying: false }));\n          }, 4500);\n        }\n        return;\n      }\n\n      // Set up event listeners for palming audio\n      audio.onloadedmetadata = () => {\n        setVoiceState(prev => ({ \n          ...prev, \n          isLoading: false, \n          duration: audio.duration \n        }));\n      };\n\n      audio.ontimeupdate = () => {\n        setVoiceState(prev => ({ \n          ...prev, \n          currentTime: audio.currentTime \n        }));\n      };\n\n      audio.onplay = () => {\n        setVoiceState(prev => ({ ...prev, isPlaying: true }));\n      };\n\n      audio.onpause = () => {\n        setVoiceState(prev => ({ ...prev, isPlaying: false }));\n      };\n\n      audio.onended = () => {\n        setVoiceState(prev => ({ \n          ...prev, \n          isPlaying: false, \n          currentTime: 0 \n        }));\n      };\n\n      audio.onerror = () => {\n        setVoiceState(prev => ({ \n          ...prev, \n          error: 'Failed to play palming instructions',\n          isLoading: false,\n          isPlaying: false \n        }));\n      };\n\n      // Pause current audio if any and play palming instructions\n      if (audioRef.current) {\n        audioRef.current.pause();\n      }\n      if (completionAudioRef.current) {\n        completionAudioRef.current.pause();\n      }\n      \n      // Reset and play\n      audio.currentTime = 0;\n      await audio.play();\n\n    } catch (error) {\n      console.error('Palming instructions voice error:', error);\n      setVoiceState(prev => ({ \n        ...prev, \n        error: error instanceof Error ? error.message : 'Failed to play palming instructions',\n        isLoading: false,\n        isPlaying: false \n      }));\n    }\n  }, []);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      // Stop all active audio elements\n      activeAudioRefs.current.forEach(audio => {\n        if (audio) {\n          audio.pause();\n        }\n      });\n      activeAudioRefs.current.clear();\n      \n      if (audioRef.current) {\n        audioRef.current.pause();\n        audioRef.current = null;\n      }\n      if (completionAudioRef.current) {\n        completionAudioRef.current.pause();\n        completionAudioRef.current = null;\n      }\n      if (palmingAudioRef.current) {\n        palmingAudioRef.current.pause();\n        palmingAudioRef.current = null;\n      }\n    };\n  }, []);\n\n  // Play palm warming guidance\n  const playPalmWarmingGuidance = useCallback(async () => {\n    if (isUsingChimes.current) {\n      await chimeService.current.playPreparationChime();\n      return;\n    }\n\n    try {\n      if (completionVoiceService.current) {\n        const audioUrl = await completionVoiceService.current.generateSpeechUrl(PALM_WARMING_TEXT);\n        const audio = new Audio(audioUrl);\n        audio.volume = 0.8;\n        \n        // Track this audio element\n        activeAudioRefs.current.add(audio);\n        \n        // Clean up when audio ends\n        audio.onended = () => {\n          activeAudioRefs.current.delete(audio);\n        };\n        \n        await audio.play();\n      } else if (webSpeechService.current) {\n        await playWebSpeech(PALM_WARMING_TEXT);\n      } else {\n        await chimeService.current.playPreparationChime();\n      }\n    } catch (error) {\n      console.error('Palm warming voice error:', error);\n      await chimeService.current.playPreparationChime();\n    }\n  }, [playWebSpeech]);\n\n  // Play eye sanctuary guidance\n  const playEyeSanctuaryGuidance = useCallback(async () => {\n    if (isUsingChimes.current) {\n      await chimeService.current.playTransitionChime();\n      return;\n    }\n\n    try {\n      if (completionVoiceService.current) {\n        const audioUrl = await completionVoiceService.current.generateSpeechUrl(EYE_SANCTUARY_TEXT);\n        const audio = new Audio(audioUrl);\n        audio.volume = 0.8;\n        \n        // Track this audio element\n        activeAudioRefs.current.add(audio);\n        \n        // Clean up when audio ends\n        audio.onended = () => {\n          activeAudioRefs.current.delete(audio);\n        };\n        \n        await audio.play();\n      } else if (webSpeechService.current) {\n        await playWebSpeech(EYE_SANCTUARY_TEXT);\n      } else {\n        await chimeService.current.playTransitionChime();\n      }\n    } catch (error) {\n      console.error('Eye sanctuary voice error:', error);\n      await chimeService.current.playTransitionChime();\n    }\n  }, [playWebSpeech]);\n\n  // Play inner sun meditation guidance\n  const playInnerSunGuidance = useCallback(async () => {\n    if (isUsingChimes.current) {\n      await chimeService.current.playPalmingChime();\n      return;\n    }\n\n    try {\n      if (completionVoiceService.current) {\n        const audioUrl = await completionVoiceService.current.generateSpeechUrl(INNER_SUN_MEDITATION_TEXT);\n        const audio = new Audio(audioUrl);\n        audio.volume = 0.8;\n        \n        // Track this audio element\n        activeAudioRefs.current.add(audio);\n        \n        // Clean up when audio ends\n        audio.onended = () => {\n          activeAudioRefs.current.delete(audio);\n        };\n        \n        await audio.play();\n      } else if (webSpeechService.current) {\n        await playWebSpeech(INNER_SUN_MEDITATION_TEXT);\n      } else {\n        await chimeService.current.playPalmingChime();\n      }\n    } catch (error) {\n      console.error('Inner sun voice error:', error);\n      await chimeService.current.playPalmingChime();\n    }\n  }, [playWebSpeech]);\n\n  return {\n    voiceState,\n    initializeVoice,\n    playVoice,\n    pauseVoice,\n    stopVoice,\n    playCompletionMessage,\n    playGong,\n    playPalmingInstructions,\n    playPalmWarmingGuidance,\n    playEyeSanctuaryGuidance,\n    playInnerSunGuidance,\n  };\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 614, "column": 0}, "map": {"version":3,"sources":["file:///Users/cobyobi/SUNGAZE%20APP/package.json/src/app/hooks/useProgress.ts"],"sourcesContent":["\"use client\";\n\nimport { useState, useEffect, useCallback } from 'react';\nimport { localStorage, UserProgress, PracticeSession } from '../lib/storage';\n\nexport function useProgress() {\n  const [progress, setProgress] = useState<UserProgress | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n\n  // Load progress on mount\n  useEffect(() => {\n    const loadProgress = () => {\n      // Only run on client-side\n      if (typeof window === 'undefined') {\n        setIsLoading(false);\n        return;\n      }\n      \n      try {\n        // Add a small delay to ensure DOM is ready\n        setTimeout(() => {\n          const userProgress = localStorage.getUserProgress();\n          setProgress(userProgress);\n          setIsLoading(false);\n        }, 100);\n      } catch (error) {\n        console.error('Error loading progress:', error);\n        // Fallback to default progress\n        setProgress({\n          currentDay: 1,\n          totalPractices: 0,\n          currentStreak: 0,\n          longestStreak: 0,\n          lastPracticeDate: null,\n          practiceHistory: [],\n        });\n        setIsLoading(false);\n      }\n    };\n\n    loadProgress();\n  }, []);\n\n  // Save progress whenever it changes\n  useEffect(() => {\n    if (progress && !isLoading) {\n      localStorage.saveUserProgress(progress);\n    }\n  }, [progress, isLoading]);\n\n  const completePractice = useCallback((duration: number, timeOfDay: 'sunrise' | 'sunset' | 'other') => {\n    try {\n      const session: PracticeSession = {\n        date: new Date().toISOString().split('T')[0],\n        duration,\n        timeOfDay,\n      };\n\n      // Add the session and let storage handle progress updates\n      localStorage.addPracticeSession(session);\n      \n      // Reload progress from storage\n      const updatedProgress = localStorage.getUserProgress();\n      setProgress(updatedProgress);\n    } catch (error) {\n      console.error('Error completing practice:', error);\n    }\n  }, []);\n\n  const advanceDay = useCallback(() => {\n    if (!progress || progress.currentDay >= 270) return;\n    \n    const newProgress = {\n      ...progress,\n      currentDay: progress.currentDay + 1,\n    };\n    \n    setProgress(newProgress);\n  }, [progress]);\n\n  const resetProgress = useCallback(() => {\n    const defaultProgress = localStorage.getDefaultProgress();\n    setProgress(defaultProgress);\n  }, []);\n\n  const getTodaysPractices = useCallback(() => {\n    if (!progress) return [];\n    \n    const today = new Date().toISOString().split('T')[0];\n    return progress.practiceHistory.filter(session => session.date === today);\n  }, [progress]);\n\n  const getTodaysTotalTime = useCallback(() => {\n    const todaysPractices = getTodaysPractices();\n    return todaysPractices.reduce((total, session) => total + session.duration, 0);\n  }, [getTodaysPractices]);\n\n  const getCurrentDayTarget = useCallback(() => {\n    if (!progress) return 10;\n    return progress.currentDay * 10; // 10 seconds per day\n  }, [progress]);\n\n  const hasCompletedToday = useCallback(() => {\n    const todaysTotal = getTodaysTotalTime();\n    const target = getCurrentDayTarget();\n    return todaysTotal >= target;\n  }, [getTodaysTotalTime, getCurrentDayTarget]);\n\n  return {\n    progress,\n    isLoading,\n    completePractice,\n    advanceDay,\n    resetProgress,\n    getTodaysPractices,\n    getTodaysTotalTime,\n    getCurrentDayTarget,\n    hasCompletedToday,\n  };\n}"],"names":[],"mappings":";;;;AAEA;AACA;AAHA;;;AAKO,SAAS;IACd,MAAM,CAAC,UAAU,YAAY,GAAG,IAAA,oPAAQ,EAAsB;IAC9D,MAAM,CAAC,WAAW,aAAa,GAAG,IAAA,oPAAQ,EAAC;IAE3C,yBAAyB;IACzB,IAAA,qPAAS,EAAC;QACR,MAAM,eAAe;YACnB,0BAA0B;YAC1B,wCAAmC;gBACjC,aAAa;gBACb;YACF;;;QAsBF;QAEA;IACF,GAAG,EAAE;IAEL,oCAAoC;IACpC,IAAA,qPAAS,EAAC;QACR,IAAI,YAAY,CAAC,WAAW;YAC1B,+KAAY,CAAC,gBAAgB,CAAC;QAChC;IACF,GAAG;QAAC;QAAU;KAAU;IAExB,MAAM,mBAAmB,IAAA,uPAAW,EAAC,CAAC,UAAkB;QACtD,IAAI;YACF,MAAM,UAA2B;gBAC/B,MAAM,IAAI,OAAO,WAAW,GAAG,KAAK,CAAC,IAAI,CAAC,EAAE;gBAC5C;gBACA;YACF;YAEA,0DAA0D;YAC1D,+KAAY,CAAC,kBAAkB,CAAC;YAEhC,+BAA+B;YAC/B,MAAM,kBAAkB,+KAAY,CAAC,eAAe;YACpD,YAAY;QACd,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,8BAA8B;QAC9C;IACF,GAAG,EAAE;IAEL,MAAM,aAAa,IAAA,uPAAW,EAAC;QAC7B,IAAI,CAAC,YAAY,SAAS,UAAU,IAAI,KAAK;QAE7C,MAAM,cAAc;YAClB,GAAG,QAAQ;YACX,YAAY,SAAS,UAAU,GAAG;QACpC;QAEA,YAAY;IACd,GAAG;QAAC;KAAS;IAEb,MAAM,gBAAgB,IAAA,uPAAW,EAAC;QAChC,MAAM,kBAAkB,+KAAY,CAAC,kBAAkB;QACvD,YAAY;IACd,GAAG,EAAE;IAEL,MAAM,qBAAqB,IAAA,uPAAW,EAAC;QACrC,IAAI,CAAC,UAAU,OAAO,EAAE;QAExB,MAAM,QAAQ,IAAI,OAAO,WAAW,GAAG,KAAK,CAAC,IAAI,CAAC,EAAE;QACpD,OAAO,SAAS,eAAe,CAAC,MAAM,CAAC,CAAA,UAAW,QAAQ,IAAI,KAAK;IACrE,GAAG;QAAC;KAAS;IAEb,MAAM,qBAAqB,IAAA,uPAAW,EAAC;QACrC,MAAM,kBAAkB;QACxB,OAAO,gBAAgB,MAAM,CAAC,CAAC,OAAO,UAAY,QAAQ,QAAQ,QAAQ,EAAE;IAC9E,GAAG;QAAC;KAAmB;IAEvB,MAAM,sBAAsB,IAAA,uPAAW,EAAC;QACtC,IAAI,CAAC,UAAU,OAAO;QACtB,OAAO,SAAS,UAAU,GAAG,IAAI,qBAAqB;IACxD,GAAG;QAAC;KAAS;IAEb,MAAM,oBAAoB,IAAA,uPAAW,EAAC;QACpC,MAAM,cAAc;QACpB,MAAM,SAAS;QACf,OAAO,eAAe;IACxB,GAAG;QAAC;QAAoB;KAAoB;IAE5C,OAAO;QACL;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;IACF;AACF","debugId":null}},
    {"offset": {"line": 721, "column": 0}, "map": {"version":3,"sources":["file:///Users/cobyobi/SUNGAZE%20APP/package.json/src/app/hooks/useSubscription.ts"],"sourcesContent":["\"use client\";\n\nimport { useState, useEffect } from 'react';\nimport { UserProfile, UserTier } from '../types/subscription';\nimport { subscriptionService } from '../lib/database/subscription-service';\n\ninterface UseSubscriptionReturn {\n  profile: UserProfile | null;\n  loading: boolean;\n  hasAccess: (requiredTier: UserTier) => boolean;\n  isFounder: boolean;\n  isPremium: boolean;\n  refreshProfile: () => Promise<void>;\n}\n\nexport function useSubscription(userId: string): UseSubscriptionReturn {\n  const [profile, setProfile] = useState<UserProfile | null>(null);\n  const [loading, setLoading] = useState(true);\n\n  const loadProfile = async () => {\n    try {\n      setLoading(true);\n      console.log('Loading profile for userId:', userId);\n      const userProfile = await subscriptionService.getUserProfile(userId);\n      console.log('Loaded userProfile:', userProfile);\n      setProfile(userProfile);\n    } catch (error) {\n      console.error('Failed to load user profile:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  useEffect(() => {\n    if (userId) {\n      loadProfile();\n    }\n  }, [userId]);\n\n  const hasAccess = (requiredTier: UserTier): boolean => {\n    if (!profile) return false;\n    \n    // Check if subscription is active for subscription-based tiers\n    if (profile.tier === 'monthly' || profile.tier === 'yearly') {\n      if (profile.subscriptionStatus !== 'active') return false;\n    }\n    \n    // Check if founder access hasn't expired\n    if (profile.tier === 'founder_444') {\n      if (profile.expirationDate) {\n        const expiration = new Date(profile.expirationDate);\n        if (expiration <= new Date()) return false;\n      }\n    }\n\n    // Define tier hierarchy\n    const tierHierarchy = {\n      'free': 0,\n      'monthly': 1,\n      'yearly': 2,\n      'founder_444': 3\n    };\n\n    const userTierLevel = tierHierarchy[profile.tier];\n    const requiredTierLevel = tierHierarchy[requiredTier];\n\n    return userTierLevel >= requiredTierLevel;\n  };\n\n  const isFounder = profile?.tier === 'founder_444' && hasAccess('founder_444');\n  const isPremium = hasAccess('monthly');\n\n  const refreshProfile = async () => {\n    await loadProfile();\n  };\n\n  return {\n    profile,\n    loading,\n    hasAccess,\n    isFounder,\n    isPremium,\n    refreshProfile\n  };\n}"],"names":[],"mappings":";;;;AAEA;AAEA;AAJA;;;AAeO,SAAS,gBAAgB,MAAc;IAC5C,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,oPAAQ,EAAqB;IAC3D,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,oPAAQ,EAAC;IAEvC,MAAM,cAAc;QAClB,IAAI;YACF,WAAW;YACX,QAAQ,GAAG,CAAC,+BAA+B;YAC3C,MAAM,cAAc,MAAM,kNAAmB,CAAC,cAAc,CAAC;YAC7D,QAAQ,GAAG,CAAC,uBAAuB;YACnC,WAAW;QACb,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,gCAAgC;QAChD,SAAU;YACR,WAAW;QACb;IACF;IAEA,IAAA,qPAAS,EAAC;QACR,IAAI,QAAQ;YACV;QACF;IACF,GAAG;QAAC;KAAO;IAEX,MAAM,YAAY,CAAC;QACjB,IAAI,CAAC,SAAS,OAAO;QAErB,+DAA+D;QAC/D,IAAI,QAAQ,IAAI,KAAK,aAAa,QAAQ,IAAI,KAAK,UAAU;YAC3D,IAAI,QAAQ,kBAAkB,KAAK,UAAU,OAAO;QACtD;QAEA,yCAAyC;QACzC,IAAI,QAAQ,IAAI,KAAK,eAAe;YAClC,IAAI,QAAQ,cAAc,EAAE;gBAC1B,MAAM,aAAa,IAAI,KAAK,QAAQ,cAAc;gBAClD,IAAI,cAAc,IAAI,QAAQ,OAAO;YACvC;QACF;QAEA,wBAAwB;QACxB,MAAM,gBAAgB;YACpB,QAAQ;YACR,WAAW;YACX,UAAU;YACV,eAAe;QACjB;QAEA,MAAM,gBAAgB,aAAa,CAAC,QAAQ,IAAI,CAAC;QACjD,MAAM,oBAAoB,aAAa,CAAC,aAAa;QAErD,OAAO,iBAAiB;IAC1B;IAEA,MAAM,YAAY,SAAS,SAAS,iBAAiB,UAAU;IAC/D,MAAM,YAAY,UAAU;IAE5B,MAAM,iBAAiB;QACrB,MAAM;IACR;IAEA,OAAO;QACL;QACA;QACA;QACA;QACA;QACA;IACF;AACF","debugId":null}},
    {"offset": {"line": 795, "column": 0}, "map": {"version":3,"sources":["file:///Users/cobyobi/SUNGAZE%20APP/package.json/src/app/hooks/useSunVisibility.ts"],"sourcesContent":["\"use client\";\n\nimport { useState, useEffect, useCallback } from 'react';\n\nexport interface SunCondition {\n  isVisible: boolean;\n  cloudCover: number; // 0-100 percentage\n  solarWindowStart: Date | null;\n  minutesToWindow: number;\n  canGaze: boolean;\n  condition: 'clear' | 'cloudy' | 'overcast' | 'rain' | 'night';\n  message: string;\n  location?: string;\n}\n\ninterface LocationData {\n  lat: number;\n  lon: number;\n  city: string;\n  country: string;\n}\n\ninterface WeatherData {\n  cloudCover: number;\n  weatherCondition: string;\n  temperature: number;\n  visibility: number;\n}\n\n// Real weather detection using location and weather API\nexport function useSunVisibility() {\n  const [sunCondition, setSunCondition] = useState<SunCondition>({\n    isVisible: true,\n    cloudCover: 20,\n    solarWindowStart: null,\n    minutesToWindow: 0,\n    canGaze: true,\n    condition: 'clear',\n    message: 'Detecting your location for accurate conditions...',\n    location: 'Unknown'\n  });\n\n  const [isLoading, setIsLoading] = useState(true);\n  const [locationData, setLocationData] = useState<LocationData | null>(null);\n\n  // Get user's location with better fallbacks\n  const getUserLocation = useCallback((): Promise<LocationData> => {\n    return new Promise((resolve) => {\n      // Always resolve with a fallback - never reject\n      const fallbackLocation: LocationData = {\n        lat: 34.0522, // Los Angeles coordinates as fallback\n        lon: -118.2437,\n        city: 'Your Location',\n        country: ''\n      };\n\n      if (!navigator.geolocation) {\n        console.info('Geolocation not supported, using fallback location');\n        resolve(fallbackLocation);\n        return;\n      }\n\n      // Try to get location with shorter timeout and better error handling\n      navigator.geolocation.getCurrentPosition(\n        async (position) => {\n          const { latitude, longitude } = position.coords;\n          \n          // Use coordinates without API calls to avoid complexity\n          const location: LocationData = {\n            lat: latitude,\n            lon: longitude,\n            city: 'Your Location',\n            country: ''\n          };\n          \n          resolve(location);\n        },\n        (error) => {\n          // Handle permission denied gracefully\n          console.info('Location permission denied or unavailable, using fallback');\n          resolve(fallbackLocation);\n        },\n        { \n          timeout: 5000, // Shorter timeout\n          maximumAge: 600000, // 10 minutes cache\n          enableHighAccuracy: false // Less intrusive\n        }\n      );\n    });\n  }, []);\n\n  // Fetch weather data for location\n  const getWeatherData = useCallback(async (location: LocationData): Promise<WeatherData | null> => {\n    try {\n      const apiKey = process.env.NEXT_PUBLIC_OPENWEATHER_API_KEY;\n      if (!apiKey) {\n        console.warn('OpenWeather API key not found');\n        return null;\n      }\n\n      const response = await fetch(\n        `https://api.openweathermap.org/data/2.5/weather?lat=${location.lat}&lon=${location.lon}&appid=${apiKey}&units=imperial`\n      );\n\n      if (!response.ok) {\n        throw new Error('Weather API request failed');\n      }\n\n      const data = await response.json();\n      \n      return {\n        cloudCover: data.clouds?.all || 0,\n        weatherCondition: data.weather?.[0]?.main || 'Clear',\n        temperature: data.main?.temp || 70,\n        visibility: data.visibility ? data.visibility / 1000 : 10 // Convert to km\n      };\n    } catch (error) {\n      console.error('Weather fetch error:', error);\n      return null;\n    }\n  }, []);\n\n  // Detect sun conditions based on time with optional location\n  const checkSunConditions = useCallback(async () => {\n    console.log('ðŸŒ¤ï¸ checkSunConditions called');\n    const now = new Date();\n    const hour = now.getHours();\n    const timeOfDay = hour >= 6 && hour <= 18 ? 'day' : 'night';\n    console.log(`ðŸŒ¤ï¸ Current time: ${hour}:00, timeOfDay: ${timeOfDay}`);\n    \n    let condition: SunCondition['condition'] = 'clear';\n    let isVisible = true;\n    let cloudCover = 15; // Default clear conditions\n    let canGaze = true;\n    let message = 'Perfect conditions for sun gazing';\n    let solarWindowStart: Date | null = null;\n    let minutesToWindow = 0;\n    let location = 'Your Location';\n\n    // Try to get location if not already available, but don't block on it\n    try {\n      if (!locationData) {\n        const userLocation = await getUserLocation();\n        setLocationData(userLocation);\n        location = userLocation.city || 'Your Location';\n      } else {\n        location = locationData.city || 'Your Location';\n      }\n    } catch (error) {\n      // Silently use fallback - no error messages\n      console.debug('Using fallback location');\n    }\n\n    // Try to get real weather data if location is available\n    try {\n      if (locationData) {\n        const weatherData = await getWeatherData(locationData);\n        if (weatherData) {\n          // Use real weather data but make changes more gradual\n          const currentCloudCover = sunCondition.cloudCover;\n          const realCloudCover = weatherData.cloudCover;\n          \n          // Gradual transition to real data (avoid dramatic jumps)\n          if (Math.abs(realCloudCover - currentCloudCover) > 20) {\n            // If difference is large, make gradual change\n            cloudCover = currentCloudCover + (realCloudCover - currentCloudCover) * 0.3;\n          } else {\n            cloudCover = realCloudCover;\n          }\n          \n          // Adjust conditions based on real weather\n          if (cloudCover > 60) {\n            condition = 'cloudy';\n            message = 'Cloudy conditions detected. Consider cloud gazing practice.';\n          } else if (cloudCover > 30) {\n            condition = 'cloudy';\n            message = 'Partly cloudy. Good conditions for sun gazing.';\n          } else {\n            condition = 'clear';\n            message = 'Clear conditions. Perfect for sun gazing.';\n          }\n        }\n      }\n    } catch (error) {\n      console.debug('Weather data unavailable, using time-based conditions');\n    }\n\n    if (timeOfDay === 'night') {\n      condition = 'night';\n      isVisible = false;\n      canGaze = false;\n      message = 'Sun practice available at sunrise';\n      \n      // Calculate time to sunrise (simulate 6 AM)\n      const tomorrow = new Date(now);\n      tomorrow.setDate(tomorrow.getDate() + 1);\n      tomorrow.setHours(6, 0, 0, 0);\n      solarWindowStart = tomorrow;\n      minutesToWindow = Math.floor((tomorrow.getTime() - now.getTime()) / (1000 * 60));\n    } else {\n      // Day time conditions - simplified logic\n      condition = 'clear';\n      isVisible = true;\n      canGaze = true;\n      \n      // Check if we're in safe gazing window based on time\n      if (hour >= 6 && hour < 8) {\n        message = `Excellent morning conditions for sun gazing`;\n        cloudCover = 10;\n      } else if (hour >= 17 && hour < 19) {\n        message = `Golden hour. Perfect for evening sun practice.`;\n        cloudCover = 12;\n      } else if (hour >= 8 && hour < 10) {\n        message = `Good morning conditions. Sun intensity building.`;\n        cloudCover = 15;\n      } else if (hour >= 16 && hour < 17) {\n        message = `Clear afternoon. Evening window approaching.`;\n        cloudCover = 18;\n      } else {\n        // Midday - suggest waiting for optimal window\n        const eveningWindow = new Date(now);\n        eveningWindow.setHours(17, 0, 0, 0);\n        solarWindowStart = eveningWindow;\n        minutesToWindow = Math.floor((eveningWindow.getTime() - now.getTime()) / (1000 * 60));\n        \n        if (minutesToWindow > 0) {\n          message = `Clear skies. Your optimal window begins in ${Math.floor(minutesToWindow/60)}h ${minutesToWindow%60}m.`;\n          cloudCover = 20;\n        } else {\n          message = `Perfect evening conditions for sun gazing`;\n          cloudCover = 12;\n        }\n      }\n    }\n\n    const newCondition = {\n      isVisible,\n      cloudCover: Math.round(cloudCover),\n      solarWindowStart,\n      minutesToWindow,\n      canGaze,\n      condition,\n      message,\n      location\n    };\n    \n    console.log('ðŸŒ¤ï¸ Setting new sun condition:', newCondition);\n    setSunCondition(newCondition);\n    setIsLoading(false);\n    \n    // Force a re-render by updating a timestamp\n    setTimeout(() => {\n      console.log('ðŸŒ¤ï¸ State update completed, current condition:', newCondition);\n    }, 100);\n  }, [locationData, getWeatherData]);\n\n  // Check conditions on mount and periodically\n  useEffect(() => {\n    const runCheck = async () => {\n      try {\n        await checkSunConditions();\n      } catch (error) {\n        console.debug('Weather check failed, using defaults');\n        // Set default conditions on any error\n        setSunCondition({\n          isVisible: true,\n          cloudCover: 15,\n          solarWindowStart: null,\n          minutesToWindow: 0,\n          canGaze: true,\n          condition: 'clear',\n          message: 'Clear conditions for sun gazing',\n          location: 'Your Location'\n        });\n        setIsLoading(false);\n      }\n    };\n    \n    runCheck();\n    \n    // Update every 2 minutes (less frequent to avoid permission prompts)\n    const interval = setInterval(runCheck, 120000);\n    \n    return () => clearInterval(interval);\n  }, [checkSunConditions]);\n\n  // Manual refresh for testing\n  const refreshConditions = useCallback(async () => {\n    console.log('ðŸ”„ Refresh button clicked - starting refresh...');\n    console.log('ðŸ”„ Current sunCondition before refresh:', sunCondition);\n    setIsLoading(true);\n    \n    try {\n      // Call the actual checkSunConditions function to get real data\n      console.log('ðŸ”„ Calling checkSunConditions...');\n      await checkSunConditions();\n      console.log('âœ… Refresh completed successfully');\n    } catch (error) {\n      console.error('âŒ Manual refresh failed:', error);\n      // Fallback to a subtle update\n      const now = new Date();\n      const hour = now.getHours();\n      const timeOfDay = hour >= 6 && hour <= 18 ? 'day' : 'night';\n      \n      // Only make subtle changes to show refresh worked\n      const currentCloudCover = sunCondition.cloudCover;\n      const newCloudCover = Math.max(5, Math.min(50, currentCloudCover + (Math.random() - 0.5) * 6)); // Â±3% change\n      \n      const newCondition = {\n        ...sunCondition,\n        cloudCover: Math.round(newCloudCover),\n        message: sunCondition.message, // Keep original message\n      };\n      \n      console.log('ðŸ”„ Setting fallback condition:', newCondition);\n      setSunCondition(newCondition);\n      setIsLoading(false);\n    }\n  }, [checkSunConditions, sunCondition]);\n\n  return {\n    sunCondition,\n    isLoading,\n    refreshConditions\n  };\n}\n\n// Helper functions\nexport function getSunPhase(hour: number): 'sunrise' | 'morning' | 'midday' | 'evening' | 'sunset' | 'night' {\n  if (hour >= 5 && hour < 7) return 'sunrise';\n  if (hour >= 7 && hour < 11) return 'morning';\n  if (hour >= 11 && hour < 15) return 'midday';\n  if (hour >= 15 && hour < 17) return 'evening';\n  if (hour >= 17 && hour < 19) return 'sunset';\n  return 'night';\n}\n\nexport function getOptimalGazingTime(condition: SunCondition['condition'], cloudCover: number): number {\n  switch (condition) {\n    case 'clear':\n      return cloudCover < 10 ? 60 : 120; // 1-2 minutes for clear skies\n    case 'cloudy':\n      return 300; // 5 minutes for cloudy (safer)\n    case 'overcast':\n      return 0; // No direct gazing\n    case 'night':\n      return 0;\n    default:\n      return 60;\n  }\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1096, "column": 0}, "map": {"version":3,"sources":["file:///Users/cobyobi/SUNGAZE%20APP/package.json/src/app/hooks/useSolarWindowNotifications.ts"],"sourcesContent":["// Hook for managing solar window notifications and reminders\nimport { useState, useEffect, useCallback } from 'react';\nimport { weatherService } from '../lib/weatherService';\n\nexport interface NotificationPreferences {\n  morningReminder: boolean;\n  eveningReminder: boolean;\n  reminderTime: number; // minutes before sunrise/sunset\n  enabled: boolean;\n}\n\nconst DEFAULT_PREFERENCES: NotificationPreferences = {\n  morningReminder: true,\n  eveningReminder: true,\n  reminderTime: 15, // 15 minutes before\n  enabled: true\n};\n\nconst STORAGE_KEY = 'solar_window_notifications';\n\nexport function useSolarWindowNotifications() {\n  const [preferences, setPreferences] = useState<NotificationPreferences>(DEFAULT_PREFERENCES);\n  const [isNotificationVisible, setIsNotificationVisible] = useState(false);\n  const [lastChecked, setLastChecked] = useState<number>(0);\n\n  // Load preferences from localStorage\n  useEffect(() => {\n    try {\n      const stored = localStorage.getItem(STORAGE_KEY);\n      if (stored) {\n        const parsed = JSON.parse(stored);\n        setPreferences({ ...DEFAULT_PREFERENCES, ...parsed });\n      }\n    } catch (error) {\n      console.error('Failed to load notification preferences:', error);\n    }\n  }, []);\n\n  // Save preferences to localStorage\n  const savePreferences = useCallback((newPreferences: NotificationPreferences) => {\n    try {\n      localStorage.setItem(STORAGE_KEY, JSON.stringify(newPreferences));\n      setPreferences(newPreferences);\n    } catch (error) {\n      console.error('Failed to save notification preferences:', error);\n    }\n  }, []);\n\n  // Check if we should show a notification\n  const checkForSolarWindow = useCallback(async () => {\n    if (!preferences.enabled) return;\n\n    // Don't check too frequently (max once per 5 minutes)\n    const now = Date.now();\n    if (now - lastChecked < 5 * 60 * 1000) return;\n\n    try {\n      const result = await weatherService.shouldTriggerSolarWindow();\n      \n      if (result.shouldTrigger) {\n        // Check if this is a time we want to be reminded about\n        const isMorning = result.isSunrise;\n        const shouldRemind = (isMorning && preferences.morningReminder) || \n                           (!isMorning && preferences.eveningReminder);\n\n        if (shouldRemind) {\n          setIsNotificationVisible(true);\n        }\n      }\n    } catch (error) {\n      console.error('Failed to check solar window:', error);\n    } finally {\n      setLastChecked(now);\n    }\n  }, [preferences, lastChecked]);\n\n  // Start periodic checking\n  useEffect(() => {\n    if (!preferences.enabled) return;\n\n    // Check immediately\n    checkForSolarWindow();\n\n    // Set up interval for periodic checking\n    const interval = setInterval(checkForSolarWindow, 5 * 60 * 1000); // Every 5 minutes\n\n    return () => clearInterval(interval);\n  }, [checkForSolarWindow, preferences.enabled]);\n\n  // Handle notification close\n  const closeNotification = useCallback(() => {\n    setIsNotificationVisible(false);\n  }, []);\n\n  // Update preferences\n  const updatePreferences = useCallback((updates: Partial<NotificationPreferences>) => {\n    const newPreferences = { ...preferences, ...updates };\n    savePreferences(newPreferences);\n  }, [preferences, savePreferences]);\n\n  // Enable/disable notifications\n  const toggleNotifications = useCallback(() => {\n    updatePreferences({ enabled: !preferences.enabled });\n  }, [preferences.enabled, updatePreferences]);\n\n  // Set reminder time\n  const setReminderTime = useCallback((minutes: number) => {\n    updatePreferences({ reminderTime: Math.max(5, Math.min(60, minutes)) });\n  }, [updatePreferences]);\n\n  // Toggle morning reminder\n  const toggleMorningReminder = useCallback(() => {\n    updatePreferences({ morningReminder: !preferences.morningReminder });\n  }, [preferences.morningReminder, updatePreferences]);\n\n  // Toggle evening reminder\n  const toggleEveningReminder = useCallback(() => {\n    updatePreferences({ eveningReminder: !preferences.eveningReminder });\n  }, [preferences.eveningReminder, updatePreferences]);\n\n  // Get cache statistics\n  const getCacheStats = useCallback(() => {\n    return weatherService.getCacheStats();\n  }, []);\n\n  // Clear caches (for testing)\n  const clearCaches = useCallback(() => {\n    weatherService.clearCaches();\n  }, []);\n\n  return {\n    preferences,\n    isNotificationVisible,\n    lastChecked,\n    updatePreferences,\n    toggleNotifications,\n    setReminderTime,\n    toggleMorningReminder,\n    toggleEveningReminder,\n    closeNotification,\n    checkForSolarWindow,\n    getCacheStats,\n    clearCaches\n  };\n}\n\n\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1254, "column": 0}, "map": {"version":3,"sources":["file:///Users/cobyobi/SUNGAZE%20APP/package.json/src/app/types/subscription.ts"],"sourcesContent":["export type UserTier = 'free' | 'monthly' | 'yearly' | 'founder_444';\n\nexport interface UserProfile {\n  id: string;\n  email: string;\n  tier: UserTier;\n  stripeCustomerId?: string;\n  subscriptionId?: string;\n  subscriptionStatus?: 'active' | 'canceled' | 'past_due' | 'incomplete';\n  founderNumber?: number; // 1-444 worldwide\n  purchaseDate?: string;\n  expirationDate?: string; // For founders, 3 years from purchase\n  badges: string[];\n  seals: string[];\n  createdAt: string;\n  updatedAt: string;\n}\n\nexport interface FounderSlots {\n  sold: number;\n  remaining: number;\n  lastUpdated: string;\n}\n\nexport interface PaymentProduct {\n  id: string;\n  name: string;\n  description: string;\n  price: number;\n  currency: string;\n  type: 'one_time' | 'subscription';\n  interval?: 'month' | 'year';\n  tier: UserTier;\n  stripePriceId?: string;\n}\n\nexport const PAYMENT_PRODUCTS: PaymentProduct[] = [\n  {\n    id: 'monthly',\n    name: 'Sungaze+ Monthly',\n    description: 'Unlimited ritual path - all features unlocked',\n    price: 4.99,\n    currency: 'USD',\n    type: 'subscription',\n    interval: 'month',\n    tier: 'monthly',\n    stripePriceId: 'price_1SB3p8GIDaitR9oVu9Br2RJB',\n  },\n  {\n    id: 'yearly',\n    name: 'Sungaze+ Yearly',\n    description: 'Infinite return for one year - best value',\n    price: 29.99,\n    currency: 'USD',\n    type: 'subscription',\n    interval: 'year',\n    tier: 'yearly',\n    stripePriceId: process.env.STRIPE_PREMIUM_PRICE_ID || 'price_1S4RCeGIDaitR9oVNXvlNVRF',\n  },\n  {\n    id: 'founder_444',\n    name: 'Founder 444',\n    description: '3 years full access. Only 444 ever.',\n    price: 99,\n    currency: 'USD',\n    type: 'one_time',\n    tier: 'founder_444',\n    stripePriceId: process.env.STRIPE_FOUNDER_PRICE_ID || 'price_1S4REHGIDaitR9oVV134V0tQ',\n  },\n];\n\nexport const FOUNDER_BADGES = [\n  'First Witness of the Flame',\n  'Solar Pioneer',\n  'Guardian of Ancient Light'\n];\n\nexport const TIER_FEATURES = {\n  free: [\n    '1-minute timer only',\n    'Basic streaks',\n    '1 koan per week',\n    'Mini journal (3 entries max)'\n  ],\n  monthly: [\n    'Unlimited timer duration',\n    'All ritual timers',\n    'Unlimited koans & wisdom',\n    'Full journal access',\n    'Sacred seals & badges',\n    'Audio transmissions',\n    'Advanced progress tracking'\n  ],\n  yearly: [\n    'Everything in Monthly',\n    'Best value (save $31.20)',\n    'Yearly streak rewards',\n    'Priority support',\n    'Early feature access'\n  ],\n  founder_444: [\n    'Everything unlocked',\n    '3 years full access',\n    'Permanent Founder badge',\n    'Exclusive founder events',\n    'Direct founder access',\n    'Early/beta features',\n    'Founder seal collection'\n  ]\n};\n\nexport const FREE_TIER_LIMITS = {\n  timerMaxDuration: 60, // 1 minute in seconds\n  journalMaxEntries: 3,\n  koansPerWeek: 1,\n  streaksEnabled: true\n};"],"names":[],"mappings":";;;;;;;;;;AAoCO,MAAM,mBAAqC;IAChD;QACE,IAAI;QACJ,MAAM;QACN,aAAa;QACb,OAAO;QACP,UAAU;QACV,MAAM;QACN,UAAU;QACV,MAAM;QACN,eAAe;IACjB;IACA;QACE,IAAI;QACJ,MAAM;QACN,aAAa;QACb,OAAO;QACP,UAAU;QACV,MAAM;QACN,UAAU;QACV,MAAM;QACN,eAAe,QAAQ,GAAG,CAAC,uBAAuB,IAAI;IACxD;IACA;QACE,IAAI;QACJ,MAAM;QACN,aAAa;QACb,OAAO;QACP,UAAU;QACV,MAAM;QACN,MAAM;QACN,eAAe,QAAQ,GAAG,CAAC,uBAAuB,IAAI;IACxD;CACD;AAEM,MAAM,iBAAiB;IAC5B;IACA;IACA;CACD;AAEM,MAAM,gBAAgB;IAC3B,MAAM;QACJ;QACA;QACA;QACA;KACD;IACD,SAAS;QACP;QACA;QACA;QACA;QACA;QACA;QACA;KACD;IACD,QAAQ;QACN;QACA;QACA;QACA;QACA;KACD;IACD,aAAa;QACX;QACA;QACA;QACA;QACA;QACA;QACA;KACD;AACH;AAEO,MAAM,mBAAmB;IAC9B,kBAAkB;IAClB,mBAAmB;IACnB,cAAc;IACd,gBAAgB;AAClB","debugId":null}},
    {"offset": {"line": 1346, "column": 0}, "map": {"version":3,"sources":["file:///Users/cobyobi/SUNGAZE%20APP/package.json/src/app/data/truthScrolls.ts"],"sourcesContent":["export interface TruthScroll {\n  id: number;\n  myth: string;\n  truth: string;\n  category: string;\n  vibe: string; // Gen Z rebellious tone\n}\n\nexport const truthScrolls: TruthScroll[] = [\n  {\n    id: 1,\n    myth: \"The sun will blind you\",\n    truth: \"Safe gazing is possible only at sunrise/sunset when UV index is 0\",\n    category: \"Safety\",\n    vibe: \"The medical establishment wants you scared of your own star â˜€ï¸\"\n  },\n  {\n    id: 2,\n    myth: \"Sungazing is New Age nonsense\",\n    truth: \"It's in the Rig Veda, Upanishads, Taoist texts, Egyptian hymns\",\n    category: \"Ancient Wisdom\",\n    vibe: \"Your ancestors knew what Big Pharma doesn't want you to know ðŸ“œ\"\n  },\n  {\n    id: 3,\n    myth: \"Humans need artificial supplements\",\n    truth: \"The sun is the original source of vitamin D, circadian alignment, and pineal activation\",\n    category: \"Health\",\n    vibe: \"Nature is the ultimate pharmacy. No cap. ðŸ’Šâž¡ï¸â˜€ï¸\"\n  },\n  {\n    id: 4,\n    myth: \"You need sunscreen all day\",\n    truth: \"Morning and evening sun exposure builds natural protection and melanin\",\n    category: \"Protection\",\n    vibe: \"They sold you fear, not freedom âœ¨\"\n  },\n  {\n    id: 5,\n    myth: \"Only food gives you energy\",\n    truth: \"Light is the primary energy source - mitochondria literally eat photons\",\n    category: \"Energy\",\n    vibe: \"You're not just what you eat, you're what you absorb ðŸŒ…\"\n  },\n  {\n    id: 6,\n    myth: \"Depression needs medication\",\n    truth: \"Light deficiency is the real epidemic - sun exposure regulates serotonin naturally\",\n    category: \"Mental Health\",\n    vibe: \"The cure was always free and literally hanging in the sky ðŸŒž\"\n  },\n  {\n    id: 7,\n    myth: \"Staring at screens all day is normal\",\n    truth: \"Your eyes were designed for horizon gazing and natural light cycles\",\n    category: \"Vision\",\n    vibe: \"They trapped your gaze in a rectangle. Break free. ðŸ“±âŒ\"\n  },\n  {\n    id: 8,\n    myth: \"Sleep pills fix insomnia\",\n    truth: \"Morning sun exposure sets your circadian clock naturally\",\n    category: \"Sleep\",\n    vibe: \"Wake up with the sun, sleep like your ancestors did ðŸŒ™\"\n  },\n  {\n    id: 9,\n    myth: \"Meditation requires apps and courses\",\n    truth: \"Solar gazing is the original mindfulness practice\",\n    category: \"Consciousness\",\n    vibe: \"The ultimate app is literally a star. No subscription required â­\"\n  },\n  {\n    id: 10,\n    myth: \"Only food contains nutrients\",\n    truth: \"Sunlight provides information, energy, and healing frequencies your body craves\",\n    category: \"Nutrition\",\n    vibe: \"Light nutrition hits different. Your cells know. ðŸ§¬\"\n  }\n];\n\nexport const getRandomTruthScroll = (): TruthScroll => {\n  return truthScrolls[Math.floor(Math.random() * truthScrolls.length)];\n};\n\nexport const getTruthScrollsByCategory = (category: string): TruthScroll[] => {\n  return truthScrolls.filter(scroll => scroll.category === category);\n};\n\nexport const getAllCategories = (): string[] => {\n  return [...new Set(truthScrolls.map(scroll => scroll.category))];\n};"],"names":[],"mappings":";;;;;;;;;;AAQO,MAAM,eAA8B;IACzC;QACE,IAAI;QACJ,MAAM;QACN,OAAO;QACP,UAAU;QACV,MAAM;IACR;IACA;QACE,IAAI;QACJ,MAAM;QACN,OAAO;QACP,UAAU;QACV,MAAM;IACR;IACA;QACE,IAAI;QACJ,MAAM;QACN,OAAO;QACP,UAAU;QACV,MAAM;IACR;IACA;QACE,IAAI;QACJ,MAAM;QACN,OAAO;QACP,UAAU;QACV,MAAM;IACR;IACA;QACE,IAAI;QACJ,MAAM;QACN,OAAO;QACP,UAAU;QACV,MAAM;IACR;IACA;QACE,IAAI;QACJ,MAAM;QACN,OAAO;QACP,UAAU;QACV,MAAM;IACR;IACA;QACE,IAAI;QACJ,MAAM;QACN,OAAO;QACP,UAAU;QACV,MAAM;IACR;IACA;QACE,IAAI;QACJ,MAAM;QACN,OAAO;QACP,UAAU;QACV,MAAM;IACR;IACA;QACE,IAAI;QACJ,MAAM;QACN,OAAO;QACP,UAAU;QACV,MAAM;IACR;IACA;QACE,IAAI;QACJ,MAAM;QACN,OAAO;QACP,UAAU;QACV,MAAM;IACR;CACD;AAEM,MAAM,uBAAuB;IAClC,OAAO,YAAY,CAAC,KAAK,KAAK,CAAC,KAAK,MAAM,KAAK,aAAa,MAAM,EAAE;AACtE;AAEO,MAAM,4BAA4B,CAAC;IACxC,OAAO,aAAa,MAAM,CAAC,CAAA,SAAU,OAAO,QAAQ,KAAK;AAC3D;AAEO,MAAM,mBAAmB;IAC9B,OAAO;WAAI,IAAI,IAAI,aAAa,GAAG,CAAC,CAAA,SAAU,OAAO,QAAQ;KAAG;AAClE","debugId":null}}]
}