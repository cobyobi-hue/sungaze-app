{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/cobyobi/SUNGAZE%20APP/package.json/src/app/hooks/useProgress.ts"],"sourcesContent":["\"use client\";\n\nimport { useState, useEffect, useCallback } from 'react';\nimport { localStorage, UserProgress, PracticeSession } from '../lib/storage';\n\nexport function useProgress() {\n  const [progress, setProgress] = useState<UserProgress | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n\n  // Load progress on mount\n  useEffect(() => {\n    const loadProgress = () => {\n      // Only run on client-side\n      if (typeof window === 'undefined') {\n        setIsLoading(false);\n        return;\n      }\n      \n      try {\n        // Add a small delay to ensure DOM is ready\n        setTimeout(() => {\n          const userProgress = localStorage.getUserProgress();\n          setProgress(userProgress);\n          setIsLoading(false);\n        }, 100);\n      } catch (error) {\n        console.error('Error loading progress:', error);\n        // Fallback to default progress\n        setProgress({\n          currentDay: 1,\n          totalPractices: 0,\n          currentStreak: 0,\n          longestStreak: 0,\n          lastPracticeDate: null,\n          practiceHistory: [],\n        });\n        setIsLoading(false);\n      }\n    };\n\n    loadProgress();\n  }, []);\n\n  // Save progress whenever it changes\n  useEffect(() => {\n    if (progress && !isLoading) {\n      localStorage.saveUserProgress(progress);\n    }\n  }, [progress, isLoading]);\n\n  const completePractice = useCallback((duration: number, timeOfDay: 'sunrise' | 'sunset' | 'other') => {\n    try {\n      const session: PracticeSession = {\n        date: new Date().toISOString().split('T')[0],\n        duration,\n        timeOfDay,\n      };\n\n      // Add the session and let storage handle progress updates\n      localStorage.addPracticeSession(session);\n      \n      // Reload progress from storage\n      const updatedProgress = localStorage.getUserProgress();\n      setProgress(updatedProgress);\n    } catch (error) {\n      console.error('Error completing practice:', error);\n    }\n  }, []);\n\n  const advanceDay = useCallback(() => {\n    if (!progress || progress.currentDay >= 270) return;\n    \n    const newProgress = {\n      ...progress,\n      currentDay: progress.currentDay + 1,\n    };\n    \n    setProgress(newProgress);\n  }, [progress]);\n\n  const resetProgress = useCallback(() => {\n    const defaultProgress = localStorage.getDefaultProgress();\n    setProgress(defaultProgress);\n  }, []);\n\n  const getTodaysPractices = useCallback(() => {\n    if (!progress) return [];\n    \n    const today = new Date().toISOString().split('T')[0];\n    return progress.practiceHistory.filter(session => session.date === today);\n  }, [progress]);\n\n  const getTodaysTotalTime = useCallback(() => {\n    const todaysPractices = getTodaysPractices();\n    return todaysPractices.reduce((total, session) => total + session.duration, 0);\n  }, [getTodaysPractices]);\n\n  const getCurrentDayTarget = useCallback(() => {\n    if (!progress) return 10;\n    return progress.currentDay * 10; // 10 seconds per day\n  }, [progress]);\n\n  const hasCompletedToday = useCallback(() => {\n    const todaysTotal = getTodaysTotalTime();\n    const target = getCurrentDayTarget();\n    return todaysTotal >= target;\n  }, [getTodaysTotalTime, getCurrentDayTarget]);\n\n  return {\n    progress,\n    isLoading,\n    completePractice,\n    advanceDay,\n    resetProgress,\n    getTodaysPractices,\n    getTodaysTotalTime,\n    getCurrentDayTarget,\n    hasCompletedToday,\n  };\n}"],"names":[],"mappings":";;;;AAEA;AACA;;AAHA;;;AAKO,SAAS;;IACd,MAAM,CAAC,UAAU,YAAY,GAAG,IAAA,4MAAQ,EAAsB;IAC9D,MAAM,CAAC,WAAW,aAAa,GAAG,IAAA,4MAAQ,EAAC;IAE3C,yBAAyB;IACzB,IAAA,6MAAS;iCAAC;YACR,MAAM;sDAAe;oBACnB,0BAA0B;oBAC1B;;oBAKA,IAAI;wBACF,2CAA2C;wBAC3C;kEAAW;gCACT,MAAM,eAAe,kLAAY,CAAC,eAAe;gCACjD,YAAY;gCACZ,aAAa;4BACf;iEAAG;oBACL,EAAE,OAAO,OAAO;wBACd,QAAQ,KAAK,CAAC,2BAA2B;wBACzC,+BAA+B;wBAC/B,YAAY;4BACV,YAAY;4BACZ,gBAAgB;4BAChB,eAAe;4BACf,eAAe;4BACf,kBAAkB;4BAClB,iBAAiB,EAAE;wBACrB;wBACA,aAAa;oBACf;gBACF;;YAEA;QACF;gCAAG,EAAE;IAEL,oCAAoC;IACpC,IAAA,6MAAS;iCAAC;YACR,IAAI,YAAY,CAAC,WAAW;gBAC1B,kLAAY,CAAC,gBAAgB,CAAC;YAChC;QACF;gCAAG;QAAC;QAAU;KAAU;IAExB,MAAM,mBAAmB,IAAA,+MAAW;qDAAC,CAAC,UAAkB;YACtD,IAAI;gBACF,MAAM,UAA2B;oBAC/B,MAAM,IAAI,OAAO,WAAW,GAAG,KAAK,CAAC,IAAI,CAAC,EAAE;oBAC5C;oBACA;gBACF;gBAEA,0DAA0D;gBAC1D,kLAAY,CAAC,kBAAkB,CAAC;gBAEhC,+BAA+B;gBAC/B,MAAM,kBAAkB,kLAAY,CAAC,eAAe;gBACpD,YAAY;YACd,EAAE,OAAO,OAAO;gBACd,QAAQ,KAAK,CAAC,8BAA8B;YAC9C;QACF;oDAAG,EAAE;IAEL,MAAM,aAAa,IAAA,+MAAW;+CAAC;YAC7B,IAAI,CAAC,YAAY,SAAS,UAAU,IAAI,KAAK;YAE7C,MAAM,cAAc;gBAClB,GAAG,QAAQ;gBACX,YAAY,SAAS,UAAU,GAAG;YACpC;YAEA,YAAY;QACd;8CAAG;QAAC;KAAS;IAEb,MAAM,gBAAgB,IAAA,+MAAW;kDAAC;YAChC,MAAM,kBAAkB,kLAAY,CAAC,kBAAkB;YACvD,YAAY;QACd;iDAAG,EAAE;IAEL,MAAM,qBAAqB,IAAA,+MAAW;uDAAC;YACrC,IAAI,CAAC,UAAU,OAAO,EAAE;YAExB,MAAM,QAAQ,IAAI,OAAO,WAAW,GAAG,KAAK,CAAC,IAAI,CAAC,EAAE;YACpD,OAAO,SAAS,eAAe,CAAC,MAAM;+DAAC,CAAA,UAAW,QAAQ,IAAI,KAAK;;QACrE;sDAAG;QAAC;KAAS;IAEb,MAAM,qBAAqB,IAAA,+MAAW;uDAAC;YACrC,MAAM,kBAAkB;YACxB,OAAO,gBAAgB,MAAM;+DAAC,CAAC,OAAO,UAAY,QAAQ,QAAQ,QAAQ;8DAAE;QAC9E;sDAAG;QAAC;KAAmB;IAEvB,MAAM,sBAAsB,IAAA,+MAAW;wDAAC;YACtC,IAAI,CAAC,UAAU,OAAO;YACtB,OAAO,SAAS,UAAU,GAAG,IAAI,qBAAqB;QACxD;uDAAG;QAAC;KAAS;IAEb,MAAM,oBAAoB,IAAA,+MAAW;sDAAC;YACpC,MAAM,cAAc;YACpB,MAAM,SAAS;YACf,OAAO,eAAe;QACxB;qDAAG;QAAC;QAAoB;KAAoB;IAE5C,OAAO;QACL;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;IACF;AACF;GAlHgB","debugId":null}},
    {"offset": {"line": 159, "column": 0}, "map": {"version":3,"sources":["file:///Users/cobyobi/SUNGAZE%20APP/package.json/src/app/hooks/useSubscription.ts"],"sourcesContent":["\"use client\";\n\nimport { useState, useEffect } from 'react';\nimport { UserProfile, UserTier } from '../types/subscription';\nimport { subscriptionService } from '../lib/database/subscription-service';\n\ninterface UseSubscriptionReturn {\n  profile: UserProfile | null;\n  loading: boolean;\n  hasAccess: (requiredTier: UserTier) => boolean;\n  isFounder: boolean;\n  isPremium: boolean;\n  refreshProfile: () => Promise<void>;\n}\n\nexport function useSubscription(userId: string): UseSubscriptionReturn {\n  const [profile, setProfile] = useState<UserProfile | null>(null);\n  const [loading, setLoading] = useState(true);\n\n  const loadProfile = async () => {\n    try {\n      setLoading(true);\n      console.log('Loading profile for userId:', userId);\n      const userProfile = await subscriptionService.getUserProfile(userId);\n      console.log('Loaded userProfile:', userProfile);\n      setProfile(userProfile);\n    } catch (error) {\n      console.error('Failed to load user profile:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  useEffect(() => {\n    if (userId) {\n      loadProfile();\n    }\n  }, [userId]);\n\n  const hasAccess = (requiredTier: UserTier): boolean => {\n    if (!profile) return false;\n    \n    // Check if subscription is active for subscription-based tiers\n    if (profile.tier === 'monthly' || profile.tier === 'yearly') {\n      if (profile.subscriptionStatus !== 'active') return false;\n    }\n    \n    // Check if founder access hasn't expired\n    if (profile.tier === 'founder_444') {\n      if (profile.expirationDate) {\n        const expiration = new Date(profile.expirationDate);\n        if (expiration <= new Date()) return false;\n      }\n    }\n\n    // Define tier hierarchy\n    const tierHierarchy = {\n      'free': 0,\n      'monthly': 1,\n      'yearly': 2,\n      'founder_444': 3\n    };\n\n    const userTierLevel = tierHierarchy[profile.tier];\n    const requiredTierLevel = tierHierarchy[requiredTier];\n\n    return userTierLevel >= requiredTierLevel;\n  };\n\n  const isFounder = profile?.tier === 'founder_444' && hasAccess('founder_444');\n  const isPremium = hasAccess('monthly');\n\n  const refreshProfile = async () => {\n    await loadProfile();\n  };\n\n  return {\n    profile,\n    loading,\n    hasAccess,\n    isFounder,\n    isPremium,\n    refreshProfile\n  };\n}"],"names":[],"mappings":";;;;AAEA;AAEA;;AAJA;;;AAeO,SAAS,gBAAgB,MAAc;;IAC5C,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,4MAAQ,EAAqB;IAC3D,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,4MAAQ,EAAC;IAEvC,MAAM,cAAc;QAClB,IAAI;YACF,WAAW;YACX,QAAQ,GAAG,CAAC,+BAA+B;YAC3C,MAAM,cAAc,MAAM,qNAAmB,CAAC,cAAc,CAAC;YAC7D,QAAQ,GAAG,CAAC,uBAAuB;YACnC,WAAW;QACb,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,gCAAgC;QAChD,SAAU;YACR,WAAW;QACb;IACF;IAEA,IAAA,6MAAS;qCAAC;YACR,IAAI,QAAQ;gBACV;YACF;QACF;oCAAG;QAAC;KAAO;IAEX,MAAM,YAAY,CAAC;QACjB,IAAI,CAAC,SAAS,OAAO;QAErB,+DAA+D;QAC/D,IAAI,QAAQ,IAAI,KAAK,aAAa,QAAQ,IAAI,KAAK,UAAU;YAC3D,IAAI,QAAQ,kBAAkB,KAAK,UAAU,OAAO;QACtD;QAEA,yCAAyC;QACzC,IAAI,QAAQ,IAAI,KAAK,eAAe;YAClC,IAAI,QAAQ,cAAc,EAAE;gBAC1B,MAAM,aAAa,IAAI,KAAK,QAAQ,cAAc;gBAClD,IAAI,cAAc,IAAI,QAAQ,OAAO;YACvC;QACF;QAEA,wBAAwB;QACxB,MAAM,gBAAgB;YACpB,QAAQ;YACR,WAAW;YACX,UAAU;YACV,eAAe;QACjB;QAEA,MAAM,gBAAgB,aAAa,CAAC,QAAQ,IAAI,CAAC;QACjD,MAAM,oBAAoB,aAAa,CAAC,aAAa;QAErD,OAAO,iBAAiB;IAC1B;IAEA,MAAM,YAAY,CAAA,oBAAA,8BAAA,QAAS,IAAI,MAAK,iBAAiB,UAAU;IAC/D,MAAM,YAAY,UAAU;IAE5B,MAAM,iBAAiB;QACrB,MAAM;IACR;IAEA,OAAO;QACL;QACA;QACA;QACA;QACA;QACA;IACF;AACF;GArEgB","debugId":null}},
    {"offset": {"line": 241, "column": 0}, "map": {"version":3,"sources":["file:///Users/cobyobi/SUNGAZE%20APP/package.json/src/app/hooks/useVoice.ts"],"sourcesContent":["\"use client\";\n\nimport { useState, useRef, useCallback, useEffect } from 'react';\nimport { initializeElevenLabs, initializeCompletionVoice, SACRED_PREPARATION_TEXT, SESSION_COMPLETION_TEXT, PALMING_INSTRUCTIONS_TEXT, PALM_WARMING_TEXT, EYE_SANCTUARY_TEXT, INNER_SUN_MEDITATION_TEXT } from '../lib/elevenlabs';\nimport { initializeWebSpeech, WebSpeechService } from '../lib/speechSynthesis';\nimport { MeditativeChimes } from '../lib/meditativeChimes';\n\nexport interface VoiceState {\n  isPlaying: boolean;\n  isLoading: boolean;\n  isReady: boolean;\n  error: string | null;\n  duration: number;\n  currentTime: number;\n}\n\nexport function useVoice() {\n  const [voiceState, setVoiceState] = useState<VoiceState>({\n    isPlaying: false,\n    isLoading: false,\n    isReady: false,\n    error: null,\n    duration: 0,\n    currentTime: 0,\n  });\n\n  const autoPlayRef = useRef(false);\n\n  const audioRef = useRef<HTMLAudioElement | null>(null);\n  const completionAudioRef = useRef<HTMLAudioElement | null>(null);\n  const palmingAudioRef = useRef<HTMLAudioElement | null>(null);\n  const activeAudioRefs = useRef<Set<HTMLAudioElement>>(new Set()); // Track all active audio elements\n  const elevenLabsService = useRef(initializeElevenLabs());\n  const completionVoiceService = useRef(initializeCompletionVoice());\n  const webSpeechService = useRef<WebSpeechService | null>(null);\n  const chimeService = useRef<MeditativeChimes>(new MeditativeChimes());\n  const isUsingWebSpeech = useRef(false);\n  const isUsingChimes = useRef(false);\n\n  // Initialize and preload sacred preparation audio\n  // Preload completion message\n  const preloadCompletionMessage = useCallback(async () => {\n    if (!completionVoiceService.current) return;\n    \n    try {\n      const audioUrl = await completionVoiceService.current.generateSpeechUrl(SESSION_COMPLETION_TEXT);\n      const audio = new Audio(audioUrl);\n      completionAudioRef.current = audio;\n      audio.load(); // Preload the audio\n    } catch (error) {\n      console.error('Failed to preload completion message:', error);\n    }\n  }, []);\n\n  // Preload palming instructions\n  const preloadPalmingInstructions = useCallback(async () => {\n    if (!completionVoiceService.current) return;\n    \n    try {\n      const audioUrl = await completionVoiceService.current.generateSpeechUrl(PALMING_INSTRUCTIONS_TEXT);\n      const audio = new Audio(audioUrl);\n      palmingAudioRef.current = audio;\n      audio.load(); // Preload the audio\n    } catch (error) {\n      console.error('Failed to preload palming instructions:', error);\n    }\n  }, []);\n\n  const initializeVoice = useCallback(async (autoPlay = false) => {\n    autoPlayRef.current = autoPlay;\n    setVoiceState(prev => ({ ...prev, isLoading: true, error: null }));\n\n    // Skip problematic voice systems and go straight to chimes for better reliability\n    console.log('Initializing sacred chimes for reliable voice experience...');\n    initializeChimeFallback(autoPlay);\n  }, []);\n\n  const initializeWebSpeechFallback = useCallback((autoPlay = false) => {\n    if (!webSpeechService.current) {\n      webSpeechService.current = initializeWebSpeech();\n    }\n\n    if (!webSpeechService.current) {\n      setVoiceState(prev => ({ \n        ...prev, \n        error: 'Voice synthesis not available in this browser',\n        isLoading: false,\n        isReady: false \n      }));\n      return;\n    }\n\n    isUsingWebSpeech.current = true;\n    setVoiceState(prev => ({ \n      ...prev, \n      isLoading: false, \n      isReady: true,\n      duration: 0, // Web Speech API doesn't provide duration info\n      currentTime: 0 \n    }));\n\n    // Auto-play if requested\n    if (autoPlay) {\n      setTimeout(() => {\n        playWebSpeech(SACRED_PREPARATION_TEXT);\n      }, 100);\n    }\n  }, []);\n\n  const initializeChimeFallback = useCallback((autoPlay = false) => {\n    console.log('Initializing sacred chimes as voice fallback...');\n    \n    isUsingChimes.current = true;\n    isUsingWebSpeech.current = false;\n    \n    setVoiceState(prev => ({ \n      ...prev, \n      isLoading: false, \n      isReady: true,\n      duration: 0, // Chimes don't have specific durations\n      currentTime: 0,\n      error: null\n    }));\n\n    // Auto-play preparation chime if requested\n    if (autoPlay) {\n      setTimeout(async () => {\n        await chimeService.current.playPreparationChime();\n        setVoiceState(prev => ({ ...prev, isPlaying: true }));\n        \n        // Set playing to false after chime completes (approximately 3 seconds)\n        setTimeout(() => {\n          setVoiceState(prev => ({ ...prev, isPlaying: false }));\n        }, 3000);\n      }, 100);\n    }\n  }, []);\n\n  const playWebSpeech = useCallback(async (text: string) => {\n    if (!webSpeechService.current) return;\n\n    try {\n      setVoiceState(prev => ({ ...prev, isPlaying: true }));\n      await webSpeechService.current.speak(text);\n      setVoiceState(prev => ({ ...prev, isPlaying: false }));\n    } catch (error) {\n      console.error('Web Speech error:', error);\n      setVoiceState(prev => ({ \n        ...prev, \n        error: null, // Don't show error, just fall back to chimes\n        isPlaying: false \n      }));\n    }\n  }, []);\n\n  const playVoice = useCallback(async () => {\n    if (isUsingChimes.current) {\n      setVoiceState(prev => ({ ...prev, isPlaying: true }));\n      await chimeService.current.playPreparationChime();\n      setTimeout(() => {\n        setVoiceState(prev => ({ ...prev, isPlaying: false }));\n      }, 3000);\n    } else if (isUsingWebSpeech.current && webSpeechService.current) {\n      playWebSpeech(SACRED_PREPARATION_TEXT);\n    } else if (audioRef.current && voiceState.isReady) {\n      audioRef.current.play().catch(error => {\n        console.error('Voice playback error:', error);\n        setVoiceState(prev => ({ \n          ...prev, \n          error: 'Failed to play audio' \n        }));\n      });\n    }\n  }, [voiceState.isReady, playWebSpeech]);\n\n  const pauseVoice = useCallback(() => {\n    if (isUsingChimes.current) {\n      // Chimes can't really be paused, just stop the state\n      setVoiceState(prev => ({ ...prev, isPlaying: false }));\n    } else if (isUsingWebSpeech.current && webSpeechService.current) {\n      webSpeechService.current.pause();\n      setVoiceState(prev => ({ ...prev, isPlaying: false }));\n    } else if (audioRef.current) {\n      audioRef.current.pause();\n    }\n  }, []);\n\n  const stopVoice = useCallback(() => {\n    console.log('Stopping all voice audio...');\n    \n    // Stop all active audio elements\n    activeAudioRefs.current.forEach(audio => {\n      if (audio) {\n        audio.pause();\n        audio.currentTime = 0;\n      }\n    });\n    activeAudioRefs.current.clear();\n    \n    if (isUsingChimes.current) {\n      // Chimes naturally stop, just reset state\n      setVoiceState(prev => ({ ...prev, isPlaying: false, currentTime: 0 }));\n    } else if (isUsingWebSpeech.current && webSpeechService.current) {\n      webSpeechService.current.stop();\n      setVoiceState(prev => ({ ...prev, isPlaying: false, currentTime: 0 }));\n    } else if (audioRef.current) {\n      audioRef.current.pause();\n      audioRef.current.currentTime = 0;\n    }\n    \n    // Also stop the main audio refs\n    if (completionAudioRef.current) {\n      completionAudioRef.current.pause();\n      completionAudioRef.current.currentTime = 0;\n    }\n    if (palmingAudioRef.current) {\n      palmingAudioRef.current.pause();\n      palmingAudioRef.current.currentTime = 0;\n    }\n  }, []);\n\n  // Generate and play gong sound\n  const playGong = useCallback(() => {\n    try {\n      const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();\n      \n      // Create oscillator for the gong sound\n      const oscillator = audioContext.createOscillator();\n      const gainNode = audioContext.createGain();\n      \n      // Connect nodes\n      oscillator.connect(gainNode);\n      gainNode.connect(audioContext.destination);\n      \n      // Configure gong-like sound\n      oscillator.frequency.setValueAtTime(200, audioContext.currentTime); // Start frequency\n      oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 2); // Decay to lower frequency\n      \n      // Configure envelope (fade out)\n      gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);\n      gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 3);\n      \n      oscillator.type = 'sine';\n      oscillator.start(audioContext.currentTime);\n      oscillator.stop(audioContext.currentTime + 3);\n      \n    } catch (error) {\n      console.error('Gong sound error:', error);\n    }\n  }, []);\n\n  // Play session completion message\n  const playCompletionMessage = useCallback(async () => {\n    // Use chimes if that's our current fallback\n    if (isUsingChimes.current) {\n      setVoiceState(prev => ({ ...prev, isPlaying: true }));\n      await chimeService.current.playCompletionChime();\n      setTimeout(() => {\n        setVoiceState(prev => ({ ...prev, isPlaying: false }));\n      }, 4000); // Completion chimes are longer\n      return;\n    }\n\n    // Try Web Speech API fallback if ElevenLabs is not working\n    if (isUsingWebSpeech.current || !completionVoiceService.current) {\n      if (webSpeechService.current) {\n        await playWebSpeech(SESSION_COMPLETION_TEXT);\n      }\n      return;\n    }\n\n    try {\n      let audio = completionAudioRef.current;\n      \n      // If not preloaded, generate it now\n      if (!audio && completionVoiceService.current) {\n        setVoiceState(prev => ({ ...prev, isLoading: true, error: null }));\n        const audioUrl = await completionVoiceService.current.generateSpeechUrl(SESSION_COMPLETION_TEXT);\n        audio = new Audio(audioUrl);\n        completionAudioRef.current = audio;\n      }\n      \n      if (!audio) {\n        console.warn('ElevenLabs completion voice service not available, using fallback');\n        // Use chimes as preferred fallback over computer voice\n        if (chimeService.current) {\n          setVoiceState(prev => ({ ...prev, isPlaying: true }));\n          await chimeService.current.playCompletionChime();\n          setTimeout(() => {\n            setVoiceState(prev => ({ ...prev, isPlaying: false }));\n          }, 4000);\n        } else if (webSpeechService.current) {\n          await playWebSpeech(SESSION_COMPLETION_TEXT);\n        }\n        return;\n      }\n\n      // Set up event listeners for completion audio\n      audio.onloadedmetadata = () => {\n        setVoiceState(prev => ({ \n          ...prev, \n          isLoading: false, \n          duration: audio.duration \n        }));\n      };\n\n      audio.ontimeupdate = () => {\n        setVoiceState(prev => ({ \n          ...prev, \n          currentTime: audio.currentTime \n        }));\n      };\n\n      audio.onplay = () => {\n        setVoiceState(prev => ({ ...prev, isPlaying: true }));\n      };\n\n      audio.onpause = () => {\n        setVoiceState(prev => ({ ...prev, isPlaying: false }));\n      };\n\n      audio.onended = () => {\n        setVoiceState(prev => ({ \n          ...prev, \n          isPlaying: false, \n          currentTime: 0 \n        }));\n      };\n\n      audio.onerror = () => {\n        setVoiceState(prev => ({ \n          ...prev, \n          error: 'Failed to play completion message',\n          isLoading: false,\n          isPlaying: false \n        }));\n      };\n\n      // Pause current audio if any and play completion message\n      if (audioRef.current) {\n        audioRef.current.pause();\n      }\n      \n      // Reset and play\n      audio.currentTime = 0;\n      await audio.play();\n\n    } catch (error) {\n      console.error('Completion voice error:', error);\n      setVoiceState(prev => ({ \n        ...prev, \n        error: error instanceof Error ? error.message : 'Failed to play completion message',\n        isLoading: false,\n        isPlaying: false \n      }));\n    }\n  }, []);\n\n  // Play palming instructions message\n  const playPalmingInstructions = useCallback(async () => {\n    // Use chimes if that's our current fallback\n    if (isUsingChimes.current) {\n      setVoiceState(prev => ({ ...prev, isPlaying: true }));\n      await chimeService.current.playPalmingChime();\n      setTimeout(() => {\n        setVoiceState(prev => ({ ...prev, isPlaying: false }));\n      }, 4500); // Palming chimes are deep and longer\n      return;\n    }\n\n    try {\n      let audio = palmingAudioRef.current;\n      \n      // If not preloaded, generate it now\n      if (!audio && completionVoiceService.current) {\n        setVoiceState(prev => ({ ...prev, isLoading: true, error: null }));\n        const audioUrl = await completionVoiceService.current.generateSpeechUrl(PALMING_INSTRUCTIONS_TEXT);\n        audio = new Audio(audioUrl);\n        palmingAudioRef.current = audio;\n      }\n      \n      if (!audio) {\n        console.warn('ElevenLabs palming voice service not available, using chime fallback');\n        // Use chimes as preferred fallback\n        if (chimeService.current) {\n          setVoiceState(prev => ({ ...prev, isPlaying: true }));\n          await chimeService.current.playPalmingChime();\n          setTimeout(() => {\n            setVoiceState(prev => ({ ...prev, isPlaying: false }));\n          }, 4500);\n        }\n        return;\n      }\n\n      // Set up event listeners for palming audio\n      audio.onloadedmetadata = () => {\n        setVoiceState(prev => ({ \n          ...prev, \n          isLoading: false, \n          duration: audio.duration \n        }));\n      };\n\n      audio.ontimeupdate = () => {\n        setVoiceState(prev => ({ \n          ...prev, \n          currentTime: audio.currentTime \n        }));\n      };\n\n      audio.onplay = () => {\n        setVoiceState(prev => ({ ...prev, isPlaying: true }));\n      };\n\n      audio.onpause = () => {\n        setVoiceState(prev => ({ ...prev, isPlaying: false }));\n      };\n\n      audio.onended = () => {\n        setVoiceState(prev => ({ \n          ...prev, \n          isPlaying: false, \n          currentTime: 0 \n        }));\n      };\n\n      audio.onerror = () => {\n        setVoiceState(prev => ({ \n          ...prev, \n          error: 'Failed to play palming instructions',\n          isLoading: false,\n          isPlaying: false \n        }));\n      };\n\n      // Pause current audio if any and play palming instructions\n      if (audioRef.current) {\n        audioRef.current.pause();\n      }\n      if (completionAudioRef.current) {\n        completionAudioRef.current.pause();\n      }\n      \n      // Reset and play\n      audio.currentTime = 0;\n      await audio.play();\n\n    } catch (error) {\n      console.error('Palming instructions voice error:', error);\n      setVoiceState(prev => ({ \n        ...prev, \n        error: error instanceof Error ? error.message : 'Failed to play palming instructions',\n        isLoading: false,\n        isPlaying: false \n      }));\n    }\n  }, []);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      // Stop all active audio elements\n      activeAudioRefs.current.forEach(audio => {\n        if (audio) {\n          audio.pause();\n        }\n      });\n      activeAudioRefs.current.clear();\n      \n      if (audioRef.current) {\n        audioRef.current.pause();\n        audioRef.current = null;\n      }\n      if (completionAudioRef.current) {\n        completionAudioRef.current.pause();\n        completionAudioRef.current = null;\n      }\n      if (palmingAudioRef.current) {\n        palmingAudioRef.current.pause();\n        palmingAudioRef.current = null;\n      }\n    };\n  }, []);\n\n  // Play palm warming guidance\n  const playPalmWarmingGuidance = useCallback(async () => {\n    if (isUsingChimes.current) {\n      await chimeService.current.playPreparationChime();\n      return;\n    }\n\n    try {\n      if (completionVoiceService.current) {\n        const audioUrl = await completionVoiceService.current.generateSpeechUrl(PALM_WARMING_TEXT);\n        const audio = new Audio(audioUrl);\n        audio.volume = 0.8;\n        \n        // Track this audio element\n        activeAudioRefs.current.add(audio);\n        \n        // Clean up when audio ends\n        audio.onended = () => {\n          activeAudioRefs.current.delete(audio);\n        };\n        \n        await audio.play();\n      } else if (webSpeechService.current) {\n        await playWebSpeech(PALM_WARMING_TEXT);\n      } else {\n        await chimeService.current.playPreparationChime();\n      }\n    } catch (error) {\n      console.error('Palm warming voice error:', error);\n      await chimeService.current.playPreparationChime();\n    }\n  }, [playWebSpeech]);\n\n  // Play eye sanctuary guidance\n  const playEyeSanctuaryGuidance = useCallback(async () => {\n    if (isUsingChimes.current) {\n      await chimeService.current.playTransitionChime();\n      return;\n    }\n\n    try {\n      if (completionVoiceService.current) {\n        const audioUrl = await completionVoiceService.current.generateSpeechUrl(EYE_SANCTUARY_TEXT);\n        const audio = new Audio(audioUrl);\n        audio.volume = 0.8;\n        \n        // Track this audio element\n        activeAudioRefs.current.add(audio);\n        \n        // Clean up when audio ends\n        audio.onended = () => {\n          activeAudioRefs.current.delete(audio);\n        };\n        \n        await audio.play();\n      } else if (webSpeechService.current) {\n        await playWebSpeech(EYE_SANCTUARY_TEXT);\n      } else {\n        await chimeService.current.playTransitionChime();\n      }\n    } catch (error) {\n      console.error('Eye sanctuary voice error:', error);\n      await chimeService.current.playTransitionChime();\n    }\n  }, [playWebSpeech]);\n\n  // Play inner sun meditation guidance\n  const playInnerSunGuidance = useCallback(async () => {\n    if (isUsingChimes.current) {\n      await chimeService.current.playPalmingChime();\n      return;\n    }\n\n    try {\n      if (completionVoiceService.current) {\n        const audioUrl = await completionVoiceService.current.generateSpeechUrl(INNER_SUN_MEDITATION_TEXT);\n        const audio = new Audio(audioUrl);\n        audio.volume = 0.8;\n        \n        // Track this audio element\n        activeAudioRefs.current.add(audio);\n        \n        // Clean up when audio ends\n        audio.onended = () => {\n          activeAudioRefs.current.delete(audio);\n        };\n        \n        await audio.play();\n      } else if (webSpeechService.current) {\n        await playWebSpeech(INNER_SUN_MEDITATION_TEXT);\n      } else {\n        await chimeService.current.playPalmingChime();\n      }\n    } catch (error) {\n      console.error('Inner sun voice error:', error);\n      await chimeService.current.playPalmingChime();\n    }\n  }, [playWebSpeech]);\n\n  return {\n    voiceState,\n    initializeVoice,\n    playVoice,\n    pauseVoice,\n    stopVoice,\n    playCompletionMessage,\n    playGong,\n    playPalmingInstructions,\n    playPalmWarmingGuidance,\n    playEyeSanctuaryGuidance,\n    playInnerSunGuidance,\n  };\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1026, "column": 0}, "map": {"version":3,"sources":["file:///Users/cobyobi/SUNGAZE%20APP/package.json/src/app/hooks/useSunVisibility.ts"],"sourcesContent":["\"use client\";\n\nimport { useState, useEffect, useCallback } from 'react';\n\nexport interface SunCondition {\n  isVisible: boolean;\n  cloudCover: number; // 0-100 percentage\n  solarWindowStart: Date | null;\n  minutesToWindow: number;\n  canGaze: boolean;\n  condition: 'clear' | 'cloudy' | 'overcast' | 'rain' | 'night';\n  message: string;\n  location?: string;\n}\n\ninterface LocationData {\n  lat: number;\n  lon: number;\n  city: string;\n  country: string;\n}\n\ninterface WeatherData {\n  cloudCover: number;\n  weatherCondition: string;\n  temperature: number;\n  visibility: number;\n}\n\n// Real weather detection using location and weather API\nexport function useSunVisibility() {\n  const [sunCondition, setSunCondition] = useState<SunCondition>({\n    isVisible: true,\n    cloudCover: 20,\n    solarWindowStart: null,\n    minutesToWindow: 0,\n    canGaze: true,\n    condition: 'clear',\n    message: 'Detecting your location for accurate conditions...',\n    location: 'Unknown'\n  });\n\n  const [isLoading, setIsLoading] = useState(true);\n  const [locationData, setLocationData] = useState<LocationData | null>(null);\n\n  // Get user's location with better fallbacks\n  const getUserLocation = useCallback((): Promise<LocationData> => {\n    return new Promise((resolve) => {\n      // Always resolve with a fallback - never reject\n      const fallbackLocation: LocationData = {\n        lat: 34.0522, // Los Angeles coordinates as fallback\n        lon: -118.2437,\n        city: 'Your Location',\n        country: ''\n      };\n\n      if (!navigator.geolocation) {\n        console.info('Geolocation not supported, using fallback location');\n        resolve(fallbackLocation);\n        return;\n      }\n\n      // Try to get location with shorter timeout and better error handling\n      navigator.geolocation.getCurrentPosition(\n        async (position) => {\n          const { latitude, longitude } = position.coords;\n          \n          // Use coordinates without API calls to avoid complexity\n          const location: LocationData = {\n            lat: latitude,\n            lon: longitude,\n            city: 'Your Location',\n            country: ''\n          };\n          \n          resolve(location);\n        },\n        (error) => {\n          // Handle permission denied gracefully\n          console.info('Location permission denied or unavailable, using fallback');\n          resolve(fallbackLocation);\n        },\n        { \n          timeout: 5000, // Shorter timeout\n          maximumAge: 600000, // 10 minutes cache\n          enableHighAccuracy: false // Less intrusive\n        }\n      );\n    });\n  }, []);\n\n  // Fetch weather data for location\n  const getWeatherData = useCallback(async (location: LocationData): Promise<WeatherData | null> => {\n    try {\n      const apiKey = process.env.NEXT_PUBLIC_OPENWEATHER_API_KEY;\n      if (!apiKey) {\n        console.warn('OpenWeather API key not found');\n        return null;\n      }\n\n      const response = await fetch(\n        `https://api.openweathermap.org/data/2.5/weather?lat=${location.lat}&lon=${location.lon}&appid=${apiKey}&units=imperial`\n      );\n\n      if (!response.ok) {\n        throw new Error('Weather API request failed');\n      }\n\n      const data = await response.json();\n      \n      return {\n        cloudCover: data.clouds?.all || 0,\n        weatherCondition: data.weather?.[0]?.main || 'Clear',\n        temperature: data.main?.temp || 70,\n        visibility: data.visibility ? data.visibility / 1000 : 10 // Convert to km\n      };\n    } catch (error) {\n      console.error('Weather fetch error:', error);\n      return null;\n    }\n  }, []);\n\n  // Detect sun conditions based on time with optional location\n  const checkSunConditions = useCallback(async () => {\n    console.log('🌤️ checkSunConditions called');\n    const now = new Date();\n    const hour = now.getHours();\n    const timeOfDay = hour >= 6 && hour <= 18 ? 'day' : 'night';\n    console.log(`🌤️ Current time: ${hour}:00, timeOfDay: ${timeOfDay}`);\n    \n    let condition: SunCondition['condition'] = 'clear';\n    let isVisible = true;\n    let cloudCover = 15; // Default clear conditions\n    let canGaze = true;\n    let message = 'Perfect conditions for sun gazing';\n    let solarWindowStart: Date | null = null;\n    let minutesToWindow = 0;\n    let location = 'Your Location';\n\n    // Try to get location if not already available, but don't block on it\n    try {\n      if (!locationData) {\n        const userLocation = await getUserLocation();\n        setLocationData(userLocation);\n        location = userLocation.city || 'Your Location';\n      } else {\n        location = locationData.city || 'Your Location';\n      }\n    } catch (error) {\n      // Silently use fallback - no error messages\n      console.debug('Using fallback location');\n    }\n\n    // Try to get real weather data if location is available\n    try {\n      if (locationData) {\n        const weatherData = await getWeatherData(locationData);\n        if (weatherData) {\n          // Use real weather data but make changes more gradual\n          const currentCloudCover = sunCondition.cloudCover;\n          const realCloudCover = weatherData.cloudCover;\n          \n          // Gradual transition to real data (avoid dramatic jumps)\n          if (Math.abs(realCloudCover - currentCloudCover) > 20) {\n            // If difference is large, make gradual change\n            cloudCover = currentCloudCover + (realCloudCover - currentCloudCover) * 0.3;\n          } else {\n            cloudCover = realCloudCover;\n          }\n          \n          // Adjust conditions based on real weather\n          if (cloudCover > 60) {\n            condition = 'cloudy';\n            message = 'Cloudy conditions detected. Consider cloud gazing practice.';\n          } else if (cloudCover > 30) {\n            condition = 'cloudy';\n            message = 'Partly cloudy. Good conditions for sun gazing.';\n          } else {\n            condition = 'clear';\n            message = 'Clear conditions. Perfect for sun gazing.';\n          }\n        }\n      }\n    } catch (error) {\n      console.debug('Weather data unavailable, using time-based conditions');\n    }\n\n    if (timeOfDay === 'night') {\n      condition = 'night';\n      isVisible = false;\n      canGaze = false;\n      message = 'Sun practice available at sunrise';\n      \n      // Calculate time to sunrise (simulate 6 AM)\n      const tomorrow = new Date(now);\n      tomorrow.setDate(tomorrow.getDate() + 1);\n      tomorrow.setHours(6, 0, 0, 0);\n      solarWindowStart = tomorrow;\n      minutesToWindow = Math.floor((tomorrow.getTime() - now.getTime()) / (1000 * 60));\n    } else {\n      // Day time conditions - simplified logic\n      condition = 'clear';\n      isVisible = true;\n      canGaze = true;\n      \n      // Check if we're in safe gazing window based on time\n      if (hour >= 6 && hour < 8) {\n        message = `Excellent morning conditions for sun gazing`;\n        cloudCover = 10;\n      } else if (hour >= 17 && hour < 19) {\n        message = `Golden hour. Perfect for evening sun practice.`;\n        cloudCover = 12;\n      } else if (hour >= 8 && hour < 10) {\n        message = `Good morning conditions. Sun intensity building.`;\n        cloudCover = 15;\n      } else if (hour >= 16 && hour < 17) {\n        message = `Clear afternoon. Evening window approaching.`;\n        cloudCover = 18;\n      } else {\n        // Midday - suggest waiting for optimal window\n        const eveningWindow = new Date(now);\n        eveningWindow.setHours(17, 0, 0, 0);\n        solarWindowStart = eveningWindow;\n        minutesToWindow = Math.floor((eveningWindow.getTime() - now.getTime()) / (1000 * 60));\n        \n        if (minutesToWindow > 0) {\n          message = `Clear skies. Your optimal window begins in ${Math.floor(minutesToWindow/60)}h ${minutesToWindow%60}m.`;\n          cloudCover = 20;\n        } else {\n          message = `Perfect evening conditions for sun gazing`;\n          cloudCover = 12;\n        }\n      }\n    }\n\n    const newCondition = {\n      isVisible,\n      cloudCover: Math.round(cloudCover),\n      solarWindowStart,\n      minutesToWindow,\n      canGaze,\n      condition,\n      message,\n      location\n    };\n    \n    console.log('🌤️ Setting new sun condition:', newCondition);\n    setSunCondition(newCondition);\n    setIsLoading(false);\n    \n    // Force a re-render by updating a timestamp\n    setTimeout(() => {\n      console.log('🌤️ State update completed, current condition:', newCondition);\n    }, 100);\n  }, [locationData, getWeatherData]);\n\n  // Check conditions on mount and periodically\n  useEffect(() => {\n    const runCheck = async () => {\n      try {\n        await checkSunConditions();\n      } catch (error) {\n        console.debug('Weather check failed, using defaults');\n        // Set default conditions on any error\n        setSunCondition({\n          isVisible: true,\n          cloudCover: 15,\n          solarWindowStart: null,\n          minutesToWindow: 0,\n          canGaze: true,\n          condition: 'clear',\n          message: 'Clear conditions for sun gazing',\n          location: 'Your Location'\n        });\n        setIsLoading(false);\n      }\n    };\n    \n    runCheck();\n    \n    // Update every 2 minutes (less frequent to avoid permission prompts)\n    const interval = setInterval(runCheck, 120000);\n    \n    return () => clearInterval(interval);\n  }, [checkSunConditions]);\n\n  // Manual refresh for testing\n  const refreshConditions = useCallback(async () => {\n    console.log('🔄 Refresh button clicked - starting refresh...');\n    console.log('🔄 Current sunCondition before refresh:', sunCondition);\n    setIsLoading(true);\n    \n    try {\n      // Call the actual checkSunConditions function to get real data\n      console.log('🔄 Calling checkSunConditions...');\n      await checkSunConditions();\n      console.log('✅ Refresh completed successfully');\n    } catch (error) {\n      console.error('❌ Manual refresh failed:', error);\n      // Fallback to a subtle update\n      const now = new Date();\n      const hour = now.getHours();\n      const timeOfDay = hour >= 6 && hour <= 18 ? 'day' : 'night';\n      \n      // Only make subtle changes to show refresh worked\n      const currentCloudCover = sunCondition.cloudCover;\n      const newCloudCover = Math.max(5, Math.min(50, currentCloudCover + (Math.random() - 0.5) * 6)); // ±3% change\n      \n      const newCondition = {\n        ...sunCondition,\n        cloudCover: Math.round(newCloudCover),\n        message: sunCondition.message, // Keep original message\n      };\n      \n      console.log('🔄 Setting fallback condition:', newCondition);\n      setSunCondition(newCondition);\n      setIsLoading(false);\n    }\n  }, [checkSunConditions, sunCondition]);\n\n  return {\n    sunCondition,\n    isLoading,\n    refreshConditions\n  };\n}\n\n// Helper functions\nexport function getSunPhase(hour: number): 'sunrise' | 'morning' | 'midday' | 'evening' | 'sunset' | 'night' {\n  if (hour >= 5 && hour < 7) return 'sunrise';\n  if (hour >= 7 && hour < 11) return 'morning';\n  if (hour >= 11 && hour < 15) return 'midday';\n  if (hour >= 15 && hour < 17) return 'evening';\n  if (hour >= 17 && hour < 19) return 'sunset';\n  return 'night';\n}\n\nexport function getOptimalGazingTime(condition: SunCondition['condition'], cloudCover: number): number {\n  switch (condition) {\n    case 'clear':\n      return cloudCover < 10 ? 60 : 120; // 1-2 minutes for clear skies\n    case 'cloudy':\n      return 300; // 5 minutes for cloudy (safer)\n    case 'overcast':\n      return 0; // No direct gazing\n    case 'night':\n      return 0;\n    default:\n      return 60;\n  }\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1357, "column": 0}, "map": {"version":3,"sources":["file:///Users/cobyobi/SUNGAZE%20APP/package.json/src/app/hooks/useSolarWindowNotifications.ts"],"sourcesContent":["// Hook for managing solar window notifications and reminders\nimport { useState, useEffect, useCallback } from 'react';\nimport { weatherService } from '../lib/weatherService';\n\nexport interface NotificationPreferences {\n  morningReminder: boolean;\n  eveningReminder: boolean;\n  reminderTime: number; // minutes before sunrise/sunset\n  enabled: boolean;\n}\n\nconst DEFAULT_PREFERENCES: NotificationPreferences = {\n  morningReminder: true,\n  eveningReminder: true,\n  reminderTime: 15, // 15 minutes before\n  enabled: true\n};\n\nconst STORAGE_KEY = 'solar_window_notifications';\n\nexport function useSolarWindowNotifications() {\n  const [preferences, setPreferences] = useState<NotificationPreferences>(DEFAULT_PREFERENCES);\n  const [isNotificationVisible, setIsNotificationVisible] = useState(false);\n  const [lastChecked, setLastChecked] = useState<number>(0);\n\n  // Load preferences from localStorage\n  useEffect(() => {\n    try {\n      const stored = localStorage.getItem(STORAGE_KEY);\n      if (stored) {\n        const parsed = JSON.parse(stored);\n        setPreferences({ ...DEFAULT_PREFERENCES, ...parsed });\n      }\n    } catch (error) {\n      console.error('Failed to load notification preferences:', error);\n    }\n  }, []);\n\n  // Save preferences to localStorage\n  const savePreferences = useCallback((newPreferences: NotificationPreferences) => {\n    try {\n      localStorage.setItem(STORAGE_KEY, JSON.stringify(newPreferences));\n      setPreferences(newPreferences);\n    } catch (error) {\n      console.error('Failed to save notification preferences:', error);\n    }\n  }, []);\n\n  // Check if we should show a notification\n  const checkForSolarWindow = useCallback(async () => {\n    if (!preferences.enabled) return;\n\n    // Don't check too frequently (max once per 5 minutes)\n    const now = Date.now();\n    if (now - lastChecked < 5 * 60 * 1000) return;\n\n    try {\n      const result = await weatherService.shouldTriggerSolarWindow();\n      \n      if (result.shouldTrigger) {\n        // Check if this is a time we want to be reminded about\n        const isMorning = result.isSunrise;\n        const shouldRemind = (isMorning && preferences.morningReminder) || \n                           (!isMorning && preferences.eveningReminder);\n\n        if (shouldRemind) {\n          setIsNotificationVisible(true);\n        }\n      }\n    } catch (error) {\n      console.error('Failed to check solar window:', error);\n    } finally {\n      setLastChecked(now);\n    }\n  }, [preferences, lastChecked]);\n\n  // Start periodic checking\n  useEffect(() => {\n    if (!preferences.enabled) return;\n\n    // Check immediately\n    checkForSolarWindow();\n\n    // Set up interval for periodic checking\n    const interval = setInterval(checkForSolarWindow, 5 * 60 * 1000); // Every 5 minutes\n\n    return () => clearInterval(interval);\n  }, [checkForSolarWindow, preferences.enabled]);\n\n  // Handle notification close\n  const closeNotification = useCallback(() => {\n    setIsNotificationVisible(false);\n  }, []);\n\n  // Update preferences\n  const updatePreferences = useCallback((updates: Partial<NotificationPreferences>) => {\n    const newPreferences = { ...preferences, ...updates };\n    savePreferences(newPreferences);\n  }, [preferences, savePreferences]);\n\n  // Enable/disable notifications\n  const toggleNotifications = useCallback(() => {\n    updatePreferences({ enabled: !preferences.enabled });\n  }, [preferences.enabled, updatePreferences]);\n\n  // Set reminder time\n  const setReminderTime = useCallback((minutes: number) => {\n    updatePreferences({ reminderTime: Math.max(5, Math.min(60, minutes)) });\n  }, [updatePreferences]);\n\n  // Toggle morning reminder\n  const toggleMorningReminder = useCallback(() => {\n    updatePreferences({ morningReminder: !preferences.morningReminder });\n  }, [preferences.morningReminder, updatePreferences]);\n\n  // Toggle evening reminder\n  const toggleEveningReminder = useCallback(() => {\n    updatePreferences({ eveningReminder: !preferences.eveningReminder });\n  }, [preferences.eveningReminder, updatePreferences]);\n\n  // Get cache statistics\n  const getCacheStats = useCallback(() => {\n    return weatherService.getCacheStats();\n  }, []);\n\n  // Clear caches (for testing)\n  const clearCaches = useCallback(() => {\n    weatherService.clearCaches();\n  }, []);\n\n  return {\n    preferences,\n    isNotificationVisible,\n    lastChecked,\n    updatePreferences,\n    toggleNotifications,\n    setReminderTime,\n    toggleMorningReminder,\n    toggleEveningReminder,\n    closeNotification,\n    checkForSolarWindow,\n    getCacheStats,\n    clearCaches\n  };\n}\n\n\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1547, "column": 0}, "map": {"version":3,"sources":["file:///Users/cobyobi/SUNGAZE%20APP/package.json/src/app/types/subscription.ts"],"sourcesContent":["export type UserTier = 'free' | 'monthly' | 'yearly' | 'founder_444';\n\nexport interface UserProfile {\n  id: string;\n  email: string;\n  tier: UserTier;\n  stripeCustomerId?: string;\n  subscriptionId?: string;\n  subscriptionStatus?: 'active' | 'canceled' | 'past_due' | 'incomplete';\n  founderNumber?: number; // 1-444 worldwide\n  purchaseDate?: string;\n  expirationDate?: string; // For founders, 3 years from purchase\n  badges: string[];\n  seals: string[];\n  createdAt: string;\n  updatedAt: string;\n}\n\nexport interface FounderSlots {\n  sold: number;\n  remaining: number;\n  lastUpdated: string;\n}\n\nexport interface PaymentProduct {\n  id: string;\n  name: string;\n  description: string;\n  price: number;\n  currency: string;\n  type: 'one_time' | 'subscription';\n  interval?: 'month' | 'year';\n  tier: UserTier;\n  stripePriceId?: string;\n}\n\nexport const PAYMENT_PRODUCTS: PaymentProduct[] = [\n  {\n    id: 'monthly',\n    name: 'Sungaze+ Monthly',\n    description: 'Unlimited ritual path - all features unlocked',\n    price: 4.99,\n    currency: 'USD',\n    type: 'subscription',\n    interval: 'month',\n    tier: 'monthly',\n    stripePriceId: process.env.STRIPE_MONTHLY_PRICE_ID || 'price_1SB3p8GIDaitR9oVu9Br2RJB',\n  },\n  {\n    id: 'yearly',\n    name: 'Sungaze+ Yearly',\n    description: 'Infinite return for one year - best value',\n    price: 29.99,\n    currency: 'USD',\n    type: 'subscription',\n    interval: 'year',\n    tier: 'yearly',\n    stripePriceId: process.env.STRIPE_PREMIUM_PRICE_ID || 'price_1S4RCeGIDaitR9oVNXvlNVRF',\n  },\n  {\n    id: 'founder_444',\n    name: 'Founder 444',\n    description: '3 years full access. Only 444 ever.',\n    price: 99,\n    currency: 'USD',\n    type: 'one_time',\n    tier: 'founder_444',\n    stripePriceId: process.env.STRIPE_FOUNDER_PRICE_ID || 'price_1S4REHGIDaitR9oVV134V0tQ',\n  },\n];\n\nexport const FOUNDER_BADGES = [\n  'First Witness of the Flame',\n  'Solar Pioneer',\n  'Guardian of Ancient Light'\n];\n\nexport const TIER_FEATURES = {\n  free: [\n    '1-minute timer only',\n    'Basic streaks',\n    '1 koan per week',\n    'Mini journal (3 entries max)'\n  ],\n  monthly: [\n    'Unlimited timer duration',\n    'All ritual timers',\n    'Unlimited koans & wisdom',\n    'Full journal access',\n    'Sacred seals & badges',\n    'Audio transmissions',\n    'Advanced progress tracking'\n  ],\n  yearly: [\n    'Everything in Monthly',\n    'Best value (save $31.20)',\n    'Yearly streak rewards',\n    'Priority support',\n    'Early feature access'\n  ],\n  founder_444: [\n    'Everything unlocked',\n    '3 years full access',\n    'Permanent Founder badge',\n    'Exclusive founder events',\n    'Direct founder access',\n    'Early/beta features',\n    'Founder seal collection'\n  ]\n};\n\nexport const FREE_TIER_LIMITS = {\n  timerMaxDuration: 60, // 1 minute in seconds\n  journalMaxEntries: 3,\n  koansPerWeek: 1,\n  streaksEnabled: true\n};"],"names":[],"mappings":";;;;;;;;;;AA8CmB;AAVZ,MAAM,mBAAqC;IAChD;QACE,IAAI;QACJ,MAAM;QACN,aAAa;QACb,OAAO;QACP,UAAU;QACV,MAAM;QACN,UAAU;QACV,MAAM;QACN,eAAe,8MAAO,CAAC,GAAG,CAAC,uBAAuB,IAAI;IACxD;IACA;QACE,IAAI;QACJ,MAAM;QACN,aAAa;QACb,OAAO;QACP,UAAU;QACV,MAAM;QACN,UAAU;QACV,MAAM;QACN,eAAe,8MAAO,CAAC,GAAG,CAAC,uBAAuB,IAAI;IACxD;IACA;QACE,IAAI;QACJ,MAAM;QACN,aAAa;QACb,OAAO;QACP,UAAU;QACV,MAAM;QACN,MAAM;QACN,eAAe,8MAAO,CAAC,GAAG,CAAC,uBAAuB,IAAI;IACxD;CACD;AAEM,MAAM,iBAAiB;IAC5B;IACA;IACA;CACD;AAEM,MAAM,gBAAgB;IAC3B,MAAM;QACJ;QACA;QACA;QACA;KACD;IACD,SAAS;QACP;QACA;QACA;QACA;QACA;QACA;QACA;KACD;IACD,QAAQ;QACN;QACA;QACA;QACA;QACA;KACD;IACD,aAAa;QACX;QACA;QACA;QACA;QACA;QACA;QACA;KACD;AACH;AAEO,MAAM,mBAAmB;IAC9B,kBAAkB;IAClB,mBAAmB;IACnB,cAAc;IACd,gBAAgB;AAClB","debugId":null}},
    {"offset": {"line": 1643, "column": 0}, "map": {"version":3,"sources":["file:///Users/cobyobi/SUNGAZE%20APP/package.json/src/app/data/truthScrolls.ts"],"sourcesContent":["export interface TruthScroll {\n  id: number;\n  myth: string;\n  truth: string;\n  category: string;\n  vibe: string; // Gen Z rebellious tone\n}\n\nexport const truthScrolls: TruthScroll[] = [\n  {\n    id: 1,\n    myth: \"The sun will blind you\",\n    truth: \"Safe gazing is possible only at sunrise/sunset when UV index is 0\",\n    category: \"Safety\",\n    vibe: \"The medical establishment wants you scared of your own star ☀️\"\n  },\n  {\n    id: 2,\n    myth: \"Sungazing is New Age nonsense\",\n    truth: \"It's in the Rig Veda, Upanishads, Taoist texts, Egyptian hymns\",\n    category: \"Ancient Wisdom\",\n    vibe: \"Your ancestors knew what Big Pharma doesn't want you to know 📜\"\n  },\n  {\n    id: 3,\n    myth: \"Humans need artificial supplements\",\n    truth: \"The sun is the original source of vitamin D, circadian alignment, and pineal activation\",\n    category: \"Health\",\n    vibe: \"Nature is the ultimate pharmacy. No cap. 💊➡️☀️\"\n  },\n  {\n    id: 4,\n    myth: \"You need sunscreen all day\",\n    truth: \"Morning and evening sun exposure builds natural protection and melanin\",\n    category: \"Protection\",\n    vibe: \"They sold you fear, not freedom ✨\"\n  },\n  {\n    id: 5,\n    myth: \"Only food gives you energy\",\n    truth: \"Light is the primary energy source - mitochondria literally eat photons\",\n    category: \"Energy\",\n    vibe: \"You're not just what you eat, you're what you absorb 🌅\"\n  },\n  {\n    id: 6,\n    myth: \"Depression needs medication\",\n    truth: \"Light deficiency is the real epidemic - sun exposure regulates serotonin naturally\",\n    category: \"Mental Health\",\n    vibe: \"The cure was always free and literally hanging in the sky 🌞\"\n  },\n  {\n    id: 7,\n    myth: \"Staring at screens all day is normal\",\n    truth: \"Your eyes were designed for horizon gazing and natural light cycles\",\n    category: \"Vision\",\n    vibe: \"They trapped your gaze in a rectangle. Break free. 📱❌\"\n  },\n  {\n    id: 8,\n    myth: \"Sleep pills fix insomnia\",\n    truth: \"Morning sun exposure sets your circadian clock naturally\",\n    category: \"Sleep\",\n    vibe: \"Wake up with the sun, sleep like your ancestors did 🌙\"\n  },\n  {\n    id: 9,\n    myth: \"Meditation requires apps and courses\",\n    truth: \"Solar gazing is the original mindfulness practice\",\n    category: \"Consciousness\",\n    vibe: \"The ultimate app is literally a star. No subscription required ⭐\"\n  },\n  {\n    id: 10,\n    myth: \"Only food contains nutrients\",\n    truth: \"Sunlight provides information, energy, and healing frequencies your body craves\",\n    category: \"Nutrition\",\n    vibe: \"Light nutrition hits different. Your cells know. 🧬\"\n  }\n];\n\nexport const getRandomTruthScroll = (): TruthScroll => {\n  return truthScrolls[Math.floor(Math.random() * truthScrolls.length)];\n};\n\nexport const getTruthScrollsByCategory = (category: string): TruthScroll[] => {\n  return truthScrolls.filter(scroll => scroll.category === category);\n};\n\nexport const getAllCategories = (): string[] => {\n  return [...new Set(truthScrolls.map(scroll => scroll.category))];\n};"],"names":[],"mappings":";;;;;;;;;;AAQO,MAAM,eAA8B;IACzC;QACE,IAAI;QACJ,MAAM;QACN,OAAO;QACP,UAAU;QACV,MAAM;IACR;IACA;QACE,IAAI;QACJ,MAAM;QACN,OAAO;QACP,UAAU;QACV,MAAM;IACR;IACA;QACE,IAAI;QACJ,MAAM;QACN,OAAO;QACP,UAAU;QACV,MAAM;IACR;IACA;QACE,IAAI;QACJ,MAAM;QACN,OAAO;QACP,UAAU;QACV,MAAM;IACR;IACA;QACE,IAAI;QACJ,MAAM;QACN,OAAO;QACP,UAAU;QACV,MAAM;IACR;IACA;QACE,IAAI;QACJ,MAAM;QACN,OAAO;QACP,UAAU;QACV,MAAM;IACR;IACA;QACE,IAAI;QACJ,MAAM;QACN,OAAO;QACP,UAAU;QACV,MAAM;IACR;IACA;QACE,IAAI;QACJ,MAAM;QACN,OAAO;QACP,UAAU;QACV,MAAM;IACR;IACA;QACE,IAAI;QACJ,MAAM;QACN,OAAO;QACP,UAAU;QACV,MAAM;IACR;IACA;QACE,IAAI;QACJ,MAAM;QACN,OAAO;QACP,UAAU;QACV,MAAM;IACR;CACD;AAEM,MAAM,uBAAuB;IAClC,OAAO,YAAY,CAAC,KAAK,KAAK,CAAC,KAAK,MAAM,KAAK,aAAa,MAAM,EAAE;AACtE;AAEO,MAAM,4BAA4B,CAAC;IACxC,OAAO,aAAa,MAAM,CAAC,CAAA,SAAU,OAAO,QAAQ,KAAK;AAC3D;AAEO,MAAM,mBAAmB;IAC9B,OAAO;WAAI,IAAI,IAAI,aAAa,GAAG,CAAC,CAAA,SAAU,OAAO,QAAQ;KAAG;AAClE","debugId":null}}]
}